
We generate the FULL G-GRAPH: 

Generation nr.0: <C9,s0>; <C8,s0>; <C7,s0>; <C6,s0>; <C5,s0>; <C4,s0>; <C3,s0>; <C2,s0>; <C1,s0>; <C0,s0>
Generation nr.1: <C0,s0>_1; <C1,s0>_1; <C2,s0>_1; <C3,s0>_1; <C4,s0>_1; <C5,s0>_1; <C6,s0>_1; <C7,s0>_1; <C8,s0>_1; <C9,s0>_1; <C9,s1>
Generation nr.2: <C9,s1>_1; <C9,s0>_2; <C8,s0>_2; <C7,s0>_2; <C6,s0>_2; <C5,s0>_2; <C4,s0>_2; <C3,s0>_2; <C2,s0>_2; <C1,s0>_2; <C0,s0>_2; <C8,s1>
Generation nr.3: <C8,s1>_1; <C0,s0>_3; <C1,s0>_3; <C2,s0>_3; <C3,s0>_3; <C4,s0>_3; <C5,s0>_3; <C6,s0>_3; <C7,s0>_3; <C8,s0>_3; <C9,s0>_3; <C9,s1>_2; <C7,s1>
Generation nr.4: <C7,s1>_1; <C9,s1>_3; <C9,s0>_4; <C8,s0>_4; <C7,s0>_4; <C6,s0>_4; <C5,s0>_4; <C4,s0>_4; <C3,s0>_4; <C2,s0>_4; <C1,s0>_4; <C0,s0>_4; <C8,s1>_2; <C6,s1>
Generation nr.5: <C6,s1>_1; <C8,s1>_3; <C0,s0>_5; <C1,s0>_5; <C2,s0>_5; <C3,s0>_5; <C4,s0>_5; <C5,s0>_5; <C6,s0>_5; <C7,s0>_5; <C8,s0>_5; <C9,s0>_5; <C9,s1>_4; <C7,s1>_2; <C5,s1>
Generation nr.6: <C5,s1>_1; <C7,s1>_3; <C9,s1>_5; <C9,s0>_6; <C8,s0>_6; <C7,s0>_6; <C6,s0>_6; <C5,s0>_6; <C4,s0>_6; <C3,s0>_6; <C2,s0>_6; <C1,s0>_6; <C0,s0>_6; <C8,s1>_4; <C6,s1>_2; <C4,s1>
Generation nr.7: <C4,s1>_1; <C6,s1>_3; <C8,s1>_5; <C0,s0>_7; <C1,s0>_7; <C2,s0>_7; <C3,s0>_7; <C4,s0>_7; <C5,s0>_7; <C6,s0>_7; <C7,s0>_7; <C8,s0>_7; <C9,s0>_7; <C9,s1>_6; <C7,s1>_4; <C5,s1>_2; <C3,s1>
Generation nr.8: <C3,s1>_1; <C5,s1>_3; <C7,s1>_5; <C9,s1>_7; <C9,s0>_8; <C8,s0>_8; <C7,s0>_8; <C6,s0>_8; <C5,s0>_8; <C4,s0>_8; <C3,s0>_8; <C2,s0>_8; <C1,s0>_8; <C0,s0>_8; <C8,s1>_6; <C6,s1>_4; <C4,s1>_2; <C2,s1>
Generation nr.9: <C2,s1>_1; <C4,s1>_3; <C6,s1>_5; <C8,s1>_7; <C0,s0>_9; <C1,s0>_9; <C2,s0>_9; <C3,s0>_9; <C4,s0>_9; <C5,s0>_9; <C6,s0>_9; <C7,s0>_9; <C8,s0>_9; <C9,s0>_9; <C9,s1>_8; <C7,s1>_6; <C5,s1>_4; <C3,s1>_2; <C1,s1>
Generation nr.10: <C1,s1>_1; <C3,s1>_3; <C5,s1>_5; <C7,s1>_7; <C9,s1>_9; <C9,s0>_10; <C8,s0>_10; <C7,s0>_10; <C6,s0>_10; <C5,s0>_10; <C4,s0>_10; <C3,s0>_10; <C2,s0>_10; <C1,s0>_10; <C0,s0>_10; <C8,s1>_8; <C6,s1>_6; <C4,s1>_4; <C2,s1>_2; <C0,s1>
Generation nr.11: <C0,s1>_1; <C2,s1>_3; <C4,s1>_5; <C6,s1>_7; <C8,s1>_9; <C0,s0>_11; <C1,s0>_11; <C2,s0>_11; <C3,s0>_11; <C4,s0>_11; <C5,s0>_11; <C6,s0>_11; <C7,s0>_11; <C8,s0>_11; <C9,s0>_11; <C9,s1>_10; <C7,s1>_8; <C5,s1>_6; <C3,s1>_4; <C1,s1>_2; <C1,s2>
Generation nr.12: <C1,s2>_1; <C1,s1>_3; <C3,s1>_5; <C5,s1>_7; <C7,s1>_9; <C9,s1>_11; <C9,s0>_12; <C8,s0>_12; <C7,s0>_12; <C6,s0>_12; <C5,s0>_12; <C4,s0>_12; <C3,s0>_12; <C2,s0>_12; <C1,s0>_12; <C0,s0>_12; <C8,s1>_10; <C6,s1>_8; <C4,s1>_6; <C2,s1>_4; <C0,s1>_2; <C2,s2>
Generation nr.13: <C2,s2>_1; <C0,s1>_3; <C2,s1>_5; <C4,s1>_7; <C6,s1>_9; <C8,s1>_11; <C0,s0>_13; <C1,s0>_13; <C2,s0>_13; <C3,s0>_13; <C4,s0>_13; <C5,s0>_13; <C6,s0>_13; <C7,s0>_13; <C8,s0>_13; <C9,s0>_13; <C9,s1>_12; <C7,s1>_10; <C5,s1>_8; <C3,s1>_6; <C1,s1>_4; <C1,s2>_2; <C3,s2>
Generation nr.14: <C3,s2>_1; <C1,s2>_3; <C1,s1>_5; <C3,s1>_7; <C5,s1>_9; <C7,s1>_11; <C9,s1>_13; <C9,s0>_14; <C8,s0>_14; <C7,s0>_14; <C6,s0>_14; <C5,s0>_14; <C4,s0>_14; <C3,s0>_14; <C2,s0>_14; <C1,s0>_14; <C0,s0>_14; <C8,s1>_12; <C6,s1>_10; <C4,s1>_8; <C2,s1>_6; <C0,s1>_4; <C2,s2>_2; <C4,s2>
Generation nr.15: <C4,s2>_1; <C2,s2>_3; <C0,s1>_5; <C2,s1>_7; <C4,s1>_9; <C6,s1>_11; <C8,s1>_13; <C0,s0>_15; <C1,s0>_15; <C2,s0>_15; <C3,s0>_15; <C4,s0>_15; <C5,s0>_15; <C6,s0>_15; <C7,s0>_15; <C8,s0>_15; <C9,s0>_15; <C9,s1>_14; <C7,s1>_12; <C5,s1>_10; <C3,s1>_8; <C1,s1>_6; <C1,s2>_4; <C3,s2>_2; <C5,s2>
Generation nr.16: <C5,s2>_1; <C3,s2>_3; <C1,s2>_5; <C1,s1>_7; <C3,s1>_9; <C5,s1>_11; <C7,s1>_13; <C9,s1>_15; <C9,s0>_16; <C8,s0>_16; <C7,s0>_16; <C6,s0>_16; <C5,s0>_16; <C4,s0>_16; <C3,s0>_16; <C2,s0>_16; <C1,s0>_16; <C0,s0>_16; <C8,s1>_14; <C6,s1>_12; <C4,s1>_10; <C2,s1>_8; <C0,s1>_6; <C2,s2>_4; <C4,s2>_2; <C6,s2>
Generation nr.17: <C6,s2>_1; <C4,s2>_3; <C2,s2>_5; <C0,s1>_7; <C2,s1>_9; <C4,s1>_11; <C6,s1>_13; <C8,s1>_15; <C0,s0>_17; <C1,s0>_17; <C2,s0>_17; <C3,s0>_17; <C4,s0>_17; <C5,s0>_17; <C6,s0>_17; <C7,s0>_17; <C8,s0>_17; <C9,s0>_17; <C9,s1>_16; <C7,s1>_14; <C5,s1>_12; <C3,s1>_10; <C1,s1>_8; <C1,s2>_6; <C3,s2>_4; <C5,s2>_2; <C7,s2>
Generation nr.18: <C7,s2>_1; <C5,s2>_3; <C3,s2>_5; <C1,s2>_7; <C1,s1>_9; <C3,s1>_11; <C5,s1>_13; <C7,s1>_15; <C9,s1>_17; <C9,s0>_18; <C8,s0>_18; <C7,s0>_18; <C6,s0>_18; <C5,s0>_18; <C4,s0>_18; <C3,s0>_18; <C2,s0>_18; <C1,s0>_18; <C0,s0>_18; <C8,s1>_16; <C6,s1>_14; <C4,s1>_12; <C2,s1>_10; <C0,s1>_8; <C2,s2>_6; <C4,s2>_4; <C6,s2>_2; <C8,s2>
Generation nr.19: <C8,s2>_1; <C6,s2>_3; <C4,s2>_5; <C2,s2>_7; <C0,s1>_9; <C2,s1>_11; <C4,s1>_13; <C6,s1>_15; <C8,s1>_17; <C0,s0>_19; <C1,s0>_19; <C2,s0>_19; <C3,s0>_19; <C4,s0>_19; <C5,s0>_19; <C6,s0>_19; <C7,s0>_19; <C8,s0>_19; <C9,s0>_19; <C9,s1>_18; <C7,s1>_16; <C5,s1>_14; <C3,s1>_12; <C1,s1>_10; <C1,s2>_8; <C3,s2>_6; <C5,s2>_4; <C7,s2>_2; <C9,s2>

BOTTOM-UP VISIT of the G-graph. For every node we choose origin node and providers.
Total requires: p8_2
fanIn[<C7,s2>_1] := 0
fanIn[<C5,s2>_3] := 0
fanIn[<C3,s2>_5] := 0
fanIn[<C1,s2>_7] := 0
fanIn[<C1,s1>_9] := 0
fanIn[<C3,s1>_11] := 0
fanIn[<C5,s1>_13] := 0
fanIn[<C7,s1>_15] := 0
fanIn[<C9,s1>_17] := 0
fanIn[<C9,s0>_18] := 0
fanIn[<C8,s0>_18] := 0
fanIn[<C7,s0>_18] := 0
fanIn[<C6,s0>_18] := 0
fanIn[<C5,s0>_18] := 0
fanIn[<C4,s0>_18] := 0
fanIn[<C3,s0>_18] := 0
fanIn[<C2,s0>_18] := 0
fanIn[<C1,s0>_18] := 0
fanIn[<C0,s0>_18] := 0
fanIn[<C8,s1>_16] := 0
fanIn[<C6,s1>_14] := 0
fanIn[<C4,s1>_12] := 0
fanIn[<C2,s1>_10] := 0
fanIn[<C0,s1>_8] := 0
fanIn[<C2,s2>_6] := 0
fanIn[<C4,s2>_4] := 0
fanIn[<C6,s2>_2] := 0
fanIn[<C8,s2>] := 1
Nodes with fanIn values:
<C7,s2>_1, fanIn = 0 | <C5,s2>_3, fanIn = 0 | <C3,s2>_5, fanIn = 0 | <C1,s2>_7, fanIn = 0 | <C1,s1>_9, fanIn = 0 | <C3,s1>_11, fanIn = 0 | <C5,s1>_13, fanIn = 0 | <C7,s1>_15, fanIn = 0 | <C9,s1>_17, fanIn = 0 | <C9,s0>_18, fanIn = 0 | <C8,s0>_18, fanIn = 0 | <C7,s0>_18, fanIn = 0 | <C6,s0>_18, fanIn = 0 | <C5,s0>_18, fanIn = 0 | <C4,s0>_18, fanIn = 0 | <C3,s0>_18, fanIn = 0 | <C2,s0>_18, fanIn = 0 | <C1,s0>_18, fanIn = 0 | <C0,s0>_18, fanIn = 0 | <C8,s1>_16, fanIn = 0 | <C6,s1>_14, fanIn = 0 | <C4,s1>_12, fanIn = 0 | <C2,s1>_10, fanIn = 0 | <C0,s1>_8, fanIn = 0 | <C2,s2>_6, fanIn = 0 | <C4,s2>_4, fanIn = 0 | <C6,s2>_2, fanIn = 0 | <C8,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 19 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s2>
<C9,s2> is NOT an initial node => need to look for parent
<C9,s1>_17 chosen with max fanIn value
origin node chosen: <C9,s1>_17
<C9,s2> is NOT a copy => must take care of providers
list of chosen providers: <C8,s2> 
current generation: Generation nr.19: <C9,s2>
next working set, at level nr.18 : { <C8,s2> <C9,s1>_17  }
Nodes with fanIn values:
<C7,s2>_1, fanIn = 0 | <C5,s2>_3, fanIn = 0 | <C3,s2>_5, fanIn = 0 | <C1,s2>_7, fanIn = 0 | <C1,s1>_9, fanIn = 0 | <C3,s1>_11, fanIn = 0 | <C5,s1>_13, fanIn = 0 | <C7,s1>_15, fanIn = 0 | <C9,s1>_17, fanIn = 0 | <C9,s0>_18, fanIn = 0 | <C8,s0>_18, fanIn = 0 | <C7,s0>_18, fanIn = 0 | <C6,s0>_18, fanIn = 0 | <C5,s0>_18, fanIn = 0 | <C4,s0>_18, fanIn = 0 | <C3,s0>_18, fanIn = 0 | <C2,s0>_18, fanIn = 0 | <C1,s0>_18, fanIn = 0 | <C0,s0>_18, fanIn = 0 | <C8,s1>_16, fanIn = 0 | <C6,s1>_14, fanIn = 0 | <C4,s1>_12, fanIn = 0 | <C2,s1>_10, fanIn = 0 | <C0,s1>_8, fanIn = 0 | <C2,s2>_6, fanIn = 0 | <C4,s2>_4, fanIn = 0 | <C6,s2>_2, fanIn = 0 | <C8,s2>, fanIn = 1
Total requires: p7_2 | p9_1
fanIn[<C6,s2>_1] := 0
fanIn[<C4,s2>_3] := 0
fanIn[<C2,s2>_5] := 0
fanIn[<C0,s1>_7] := 0
fanIn[<C2,s1>_9] := 0
fanIn[<C4,s1>_11] := 0
fanIn[<C6,s1>_13] := 0
fanIn[<C8,s1>_15] := 0
fanIn[<C0,s0>_17] := 0
fanIn[<C1,s0>_17] := 0
fanIn[<C2,s0>_17] := 0
fanIn[<C3,s0>_17] := 0
fanIn[<C4,s0>_17] := 0
fanIn[<C5,s0>_17] := 0
fanIn[<C6,s0>_17] := 0
fanIn[<C7,s0>_17] := 0
fanIn[<C8,s0>_17] := 0
fanIn[<C9,s0>_17] := 0
fanIn[<C9,s1>_16] := 1
fanIn[<C7,s1>_14] := 0
fanIn[<C5,s1>_12] := 0
fanIn[<C3,s1>_10] := 0
fanIn[<C1,s1>_8] := 0
fanIn[<C1,s2>_6] := 0
fanIn[<C3,s2>_4] := 0
fanIn[<C5,s2>_2] := 0
fanIn[<C7,s2>] := 1
Nodes with fanIn values:
<C6,s2>_1, fanIn = 0 | <C4,s2>_3, fanIn = 0 | <C2,s2>_5, fanIn = 0 | <C0,s1>_7, fanIn = 0 | <C2,s1>_9, fanIn = 0 | <C4,s1>_11, fanIn = 0 | <C6,s1>_13, fanIn = 0 | <C8,s1>_15, fanIn = 0 | <C0,s0>_17, fanIn = 0 | <C1,s0>_17, fanIn = 0 | <C2,s0>_17, fanIn = 0 | <C3,s0>_17, fanIn = 0 | <C4,s0>_17, fanIn = 0 | <C5,s0>_17, fanIn = 0 | <C6,s0>_17, fanIn = 0 | <C7,s0>_17, fanIn = 0 | <C8,s0>_17, fanIn = 0 | <C9,s0>_17, fanIn = 0 | <C9,s1>_16, fanIn = 1 | <C7,s1>_14, fanIn = 0 | <C5,s1>_12, fanIn = 0 | <C3,s1>_10, fanIn = 0 | <C1,s1>_8, fanIn = 0 | <C1,s2>_6, fanIn = 0 | <C3,s2>_4, fanIn = 0 | <C5,s2>_2, fanIn = 0 | <C7,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 18 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s2>
<C8,s2> is NOT an initial node => need to look for parent
<C8,s1>_15 chosen with max fanIn value
origin node chosen: <C8,s1>_15
<C8,s2> is NOT a copy => must take care of providers
list of chosen providers: <C7,s2> <C9,s1>_16 
current generation: Generation nr.18: <C8,s2>
next working set, at level nr.17 : { <C7,s2> <C9,s1>_16 <C8,s1>_15  }
Nodes with fanIn values:
<C6,s2>_1, fanIn = 0 | <C4,s2>_3, fanIn = 0 | <C2,s2>_5, fanIn = 0 | <C0,s1>_7, fanIn = 0 | <C2,s1>_9, fanIn = 0 | <C4,s1>_11, fanIn = 0 | <C6,s1>_13, fanIn = 0 | <C8,s1>_15, fanIn = 0 | <C0,s0>_17, fanIn = 0 | <C1,s0>_17, fanIn = 0 | <C2,s0>_17, fanIn = 0 | <C3,s0>_17, fanIn = 0 | <C4,s0>_17, fanIn = 0 | <C5,s0>_17, fanIn = 0 | <C6,s0>_17, fanIn = 0 | <C7,s0>_17, fanIn = 0 | <C8,s0>_17, fanIn = 0 | <C9,s0>_17, fanIn = 0 | <C9,s1>_16, fanIn = 1 | <C7,s1>_14, fanIn = 0 | <C5,s1>_12, fanIn = 0 | <C3,s1>_10, fanIn = 0 | <C1,s1>_8, fanIn = 0 | <C1,s2>_6, fanIn = 0 | <C3,s2>_4, fanIn = 0 | <C5,s2>_2, fanIn = 0 | <C7,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 18 CYCLE execution nr. 2 ----------------
node to be examined: <C9,s1>_17
<C9,s1>_17 is NOT an initial node => need to look for parent
<C9,s1>_16 chosen with max fanIn value
origin node chosen: <C9,s1>_16
Update fanIn : fanIn[<C9,s1>_16] <- 0 (due to provide p9_1)
current generation: Generation nr.18: <C9,s1>_17; <C8,s2>
next working set, at level nr.17 : { <C9,s1>_16 <C7,s2> <C8,s1>_15  }
Nodes with fanIn values:
<C6,s2>_1, fanIn = 0 | <C4,s2>_3, fanIn = 0 | <C2,s2>_5, fanIn = 0 | <C0,s1>_7, fanIn = 0 | <C2,s1>_9, fanIn = 0 | <C4,s1>_11, fanIn = 0 | <C6,s1>_13, fanIn = 0 | <C8,s1>_15, fanIn = 0 | <C0,s0>_17, fanIn = 0 | <C1,s0>_17, fanIn = 0 | <C2,s0>_17, fanIn = 0 | <C3,s0>_17, fanIn = 0 | <C4,s0>_17, fanIn = 0 | <C5,s0>_17, fanIn = 0 | <C6,s0>_17, fanIn = 0 | <C7,s0>_17, fanIn = 0 | <C8,s0>_17, fanIn = 0 | <C9,s0>_17, fanIn = 0 | <C9,s1>_16, fanIn = 0 | <C7,s1>_14, fanIn = 0 | <C5,s1>_12, fanIn = 0 | <C3,s1>_10, fanIn = 0 | <C1,s1>_8, fanIn = 0 | <C1,s2>_6, fanIn = 0 | <C3,s2>_4, fanIn = 0 | <C5,s2>_2, fanIn = 0 | <C7,s2>, fanIn = 1
Total requires: p6_2 | p8_1 | p9_1
fanIn[<C5,s2>_1] := 0
fanIn[<C3,s2>_3] := 0
fanIn[<C1,s2>_5] := 0
fanIn[<C1,s1>_7] := 0
fanIn[<C3,s1>_9] := 0
fanIn[<C5,s1>_11] := 0
fanIn[<C7,s1>_13] := 0
fanIn[<C9,s1>_15] := 1
fanIn[<C9,s0>_16] := 0
fanIn[<C8,s0>_16] := 0
fanIn[<C7,s0>_16] := 0
fanIn[<C6,s0>_16] := 0
fanIn[<C5,s0>_16] := 0
fanIn[<C4,s0>_16] := 0
fanIn[<C3,s0>_16] := 0
fanIn[<C2,s0>_16] := 0
fanIn[<C1,s0>_16] := 0
fanIn[<C0,s0>_16] := 0
fanIn[<C8,s1>_14] := 1
fanIn[<C6,s1>_12] := 0
fanIn[<C4,s1>_10] := 0
fanIn[<C2,s1>_8] := 0
fanIn[<C0,s1>_6] := 0
fanIn[<C2,s2>_4] := 0
fanIn[<C4,s2>_2] := 0
fanIn[<C6,s2>] := 1
Nodes with fanIn values:
<C5,s2>_1, fanIn = 0 | <C3,s2>_3, fanIn = 0 | <C1,s2>_5, fanIn = 0 | <C1,s1>_7, fanIn = 0 | <C3,s1>_9, fanIn = 0 | <C5,s1>_11, fanIn = 0 | <C7,s1>_13, fanIn = 0 | <C9,s1>_15, fanIn = 1 | <C9,s0>_16, fanIn = 0 | <C8,s0>_16, fanIn = 0 | <C7,s0>_16, fanIn = 0 | <C6,s0>_16, fanIn = 0 | <C5,s0>_16, fanIn = 0 | <C4,s0>_16, fanIn = 0 | <C3,s0>_16, fanIn = 0 | <C2,s0>_16, fanIn = 0 | <C1,s0>_16, fanIn = 0 | <C0,s0>_16, fanIn = 0 | <C8,s1>_14, fanIn = 1 | <C6,s1>_12, fanIn = 0 | <C4,s1>_10, fanIn = 0 | <C2,s1>_8, fanIn = 0 | <C0,s1>_6, fanIn = 0 | <C2,s2>_4, fanIn = 0 | <C4,s2>_2, fanIn = 0 | <C6,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 17 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_16
<C9,s1>_16 is NOT an initial node => need to look for parent
<C9,s1>_15 chosen with max fanIn value
origin node chosen: <C9,s1>_15
Update fanIn : fanIn[<C9,s1>_15] <- 0 (due to provide p9_1)
current generation: Generation nr.17: <C9,s1>_16
next working set, at level nr.16 : { <C9,s1>_15  }
Nodes with fanIn values:
<C5,s2>_1, fanIn = 0 | <C3,s2>_3, fanIn = 0 | <C1,s2>_5, fanIn = 0 | <C1,s1>_7, fanIn = 0 | <C3,s1>_9, fanIn = 0 | <C5,s1>_11, fanIn = 0 | <C7,s1>_13, fanIn = 0 | <C9,s1>_15, fanIn = 0 | <C9,s0>_16, fanIn = 0 | <C8,s0>_16, fanIn = 0 | <C7,s0>_16, fanIn = 0 | <C6,s0>_16, fanIn = 0 | <C5,s0>_16, fanIn = 0 | <C4,s0>_16, fanIn = 0 | <C3,s0>_16, fanIn = 0 | <C2,s0>_16, fanIn = 0 | <C1,s0>_16, fanIn = 0 | <C0,s0>_16, fanIn = 0 | <C8,s1>_14, fanIn = 1 | <C6,s1>_12, fanIn = 0 | <C4,s1>_10, fanIn = 0 | <C2,s1>_8, fanIn = 0 | <C0,s1>_6, fanIn = 0 | <C2,s2>_4, fanIn = 0 | <C4,s2>_2, fanIn = 0 | <C6,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 17 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s2>
<C7,s2> is NOT an initial node => need to look for parent
<C7,s1>_13 chosen with max fanIn value
origin node chosen: <C7,s1>_13
<C7,s2> is NOT a copy => must take care of providers
list of chosen providers: <C6,s2> <C8,s1>_14 
current generation: Generation nr.17: <C7,s2>; <C9,s1>_16
next working set, at level nr.16 : { <C6,s2> <C8,s1>_14 <C7,s1>_13 <C9,s1>_15  }
Nodes with fanIn values:
<C5,s2>_1, fanIn = 0 | <C3,s2>_3, fanIn = 0 | <C1,s2>_5, fanIn = 0 | <C1,s1>_7, fanIn = 0 | <C3,s1>_9, fanIn = 0 | <C5,s1>_11, fanIn = 0 | <C7,s1>_13, fanIn = 0 | <C9,s1>_15, fanIn = 0 | <C9,s0>_16, fanIn = 0 | <C8,s0>_16, fanIn = 0 | <C7,s0>_16, fanIn = 0 | <C6,s0>_16, fanIn = 0 | <C5,s0>_16, fanIn = 0 | <C4,s0>_16, fanIn = 0 | <C3,s0>_16, fanIn = 0 | <C2,s0>_16, fanIn = 0 | <C1,s0>_16, fanIn = 0 | <C0,s0>_16, fanIn = 0 | <C8,s1>_14, fanIn = 1 | <C6,s1>_12, fanIn = 0 | <C4,s1>_10, fanIn = 0 | <C2,s1>_8, fanIn = 0 | <C0,s1>_6, fanIn = 0 | <C2,s2>_4, fanIn = 0 | <C4,s2>_2, fanIn = 0 | <C6,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 17 CYCLE execution nr. 3 ----------------
node to be examined: <C8,s1>_15
<C8,s1>_15 is NOT an initial node => need to look for parent
<C8,s1>_14 chosen with max fanIn value
origin node chosen: <C8,s1>_14
Update fanIn : fanIn[<C8,s1>_14] <- 0 (due to provide p8_1)
current generation: Generation nr.17: <C8,s1>_15; <C7,s2>; <C9,s1>_16
next working set, at level nr.16 : { <C8,s1>_14 <C6,s2> <C7,s1>_13 <C9,s1>_15  }
Nodes with fanIn values:
<C5,s2>_1, fanIn = 0 | <C3,s2>_3, fanIn = 0 | <C1,s2>_5, fanIn = 0 | <C1,s1>_7, fanIn = 0 | <C3,s1>_9, fanIn = 0 | <C5,s1>_11, fanIn = 0 | <C7,s1>_13, fanIn = 0 | <C9,s1>_15, fanIn = 0 | <C9,s0>_16, fanIn = 0 | <C8,s0>_16, fanIn = 0 | <C7,s0>_16, fanIn = 0 | <C6,s0>_16, fanIn = 0 | <C5,s0>_16, fanIn = 0 | <C4,s0>_16, fanIn = 0 | <C3,s0>_16, fanIn = 0 | <C2,s0>_16, fanIn = 0 | <C1,s0>_16, fanIn = 0 | <C0,s0>_16, fanIn = 0 | <C8,s1>_14, fanIn = 0 | <C6,s1>_12, fanIn = 0 | <C4,s1>_10, fanIn = 0 | <C2,s1>_8, fanIn = 0 | <C0,s1>_6, fanIn = 0 | <C2,s2>_4, fanIn = 0 | <C4,s2>_2, fanIn = 0 | <C6,s2>, fanIn = 1
Total requires: p9_1 | p5_2 | p7_1 | p8_1
fanIn[<C4,s2>_1] := 0
fanIn[<C2,s2>_3] := 0
fanIn[<C0,s1>_5] := 0
fanIn[<C2,s1>_7] := 0
fanIn[<C4,s1>_9] := 0
fanIn[<C6,s1>_11] := 0
fanIn[<C8,s1>_13] := 1
fanIn[<C0,s0>_15] := 0
fanIn[<C1,s0>_15] := 0
fanIn[<C2,s0>_15] := 0
fanIn[<C3,s0>_15] := 0
fanIn[<C4,s0>_15] := 0
fanIn[<C5,s0>_15] := 0
fanIn[<C6,s0>_15] := 0
fanIn[<C7,s0>_15] := 0
fanIn[<C8,s0>_15] := 0
fanIn[<C9,s0>_15] := 0
fanIn[<C9,s1>_14] := 1
fanIn[<C7,s1>_12] := 1
fanIn[<C5,s1>_10] := 0
fanIn[<C3,s1>_8] := 0
fanIn[<C1,s1>_6] := 0
fanIn[<C1,s2>_4] := 0
fanIn[<C3,s2>_2] := 0
fanIn[<C5,s2>] := 1
Nodes with fanIn values:
<C4,s2>_1, fanIn = 0 | <C2,s2>_3, fanIn = 0 | <C0,s1>_5, fanIn = 0 | <C2,s1>_7, fanIn = 0 | <C4,s1>_9, fanIn = 0 | <C6,s1>_11, fanIn = 0 | <C8,s1>_13, fanIn = 1 | <C0,s0>_15, fanIn = 0 | <C1,s0>_15, fanIn = 0 | <C2,s0>_15, fanIn = 0 | <C3,s0>_15, fanIn = 0 | <C4,s0>_15, fanIn = 0 | <C5,s0>_15, fanIn = 0 | <C6,s0>_15, fanIn = 0 | <C7,s0>_15, fanIn = 0 | <C8,s0>_15, fanIn = 0 | <C9,s0>_15, fanIn = 0 | <C9,s1>_14, fanIn = 1 | <C7,s1>_12, fanIn = 1 | <C5,s1>_10, fanIn = 0 | <C3,s1>_8, fanIn = 0 | <C1,s1>_6, fanIn = 0 | <C1,s2>_4, fanIn = 0 | <C3,s2>_2, fanIn = 0 | <C5,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 16 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>_14
<C8,s1>_14 is NOT an initial node => need to look for parent
<C8,s1>_13 chosen with max fanIn value
origin node chosen: <C8,s1>_13
Update fanIn : fanIn[<C8,s1>_13] <- 0 (due to provide p8_1)
current generation: Generation nr.16: <C8,s1>_14
next working set, at level nr.15 : { <C8,s1>_13  }
Nodes with fanIn values:
<C4,s2>_1, fanIn = 0 | <C2,s2>_3, fanIn = 0 | <C0,s1>_5, fanIn = 0 | <C2,s1>_7, fanIn = 0 | <C4,s1>_9, fanIn = 0 | <C6,s1>_11, fanIn = 0 | <C8,s1>_13, fanIn = 0 | <C0,s0>_15, fanIn = 0 | <C1,s0>_15, fanIn = 0 | <C2,s0>_15, fanIn = 0 | <C3,s0>_15, fanIn = 0 | <C4,s0>_15, fanIn = 0 | <C5,s0>_15, fanIn = 0 | <C6,s0>_15, fanIn = 0 | <C7,s0>_15, fanIn = 0 | <C8,s0>_15, fanIn = 0 | <C9,s0>_15, fanIn = 0 | <C9,s1>_14, fanIn = 1 | <C7,s1>_12, fanIn = 1 | <C5,s1>_10, fanIn = 0 | <C3,s1>_8, fanIn = 0 | <C1,s1>_6, fanIn = 0 | <C1,s2>_4, fanIn = 0 | <C3,s2>_2, fanIn = 0 | <C5,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 16 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s2>
<C6,s2> is NOT an initial node => need to look for parent
<C6,s1>_11 chosen with max fanIn value
origin node chosen: <C6,s1>_11
<C6,s2> is NOT a copy => must take care of providers
list of chosen providers: <C5,s2> <C7,s1>_12 
current generation: Generation nr.16: <C6,s2>; <C8,s1>_14
next working set, at level nr.15 : { <C5,s2> <C7,s1>_12 <C6,s1>_11 <C8,s1>_13  }
Nodes with fanIn values:
<C4,s2>_1, fanIn = 0 | <C2,s2>_3, fanIn = 0 | <C0,s1>_5, fanIn = 0 | <C2,s1>_7, fanIn = 0 | <C4,s1>_9, fanIn = 0 | <C6,s1>_11, fanIn = 0 | <C8,s1>_13, fanIn = 0 | <C0,s0>_15, fanIn = 0 | <C1,s0>_15, fanIn = 0 | <C2,s0>_15, fanIn = 0 | <C3,s0>_15, fanIn = 0 | <C4,s0>_15, fanIn = 0 | <C5,s0>_15, fanIn = 0 | <C6,s0>_15, fanIn = 0 | <C7,s0>_15, fanIn = 0 | <C8,s0>_15, fanIn = 0 | <C9,s0>_15, fanIn = 0 | <C9,s1>_14, fanIn = 1 | <C7,s1>_12, fanIn = 1 | <C5,s1>_10, fanIn = 0 | <C3,s1>_8, fanIn = 0 | <C1,s1>_6, fanIn = 0 | <C1,s2>_4, fanIn = 0 | <C3,s2>_2, fanIn = 0 | <C5,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 16 CYCLE execution nr. 3 ----------------
node to be examined: <C7,s1>_13
<C7,s1>_13 is NOT an initial node => need to look for parent
<C7,s1>_12 chosen with max fanIn value
origin node chosen: <C7,s1>_12
Update fanIn : fanIn[<C7,s1>_12] <- 0 (due to provide p7_1)
current generation: Generation nr.16: <C7,s1>_13; <C6,s2>; <C8,s1>_14
next working set, at level nr.15 : { <C7,s1>_12 <C5,s2> <C6,s1>_11 <C8,s1>_13  }
Nodes with fanIn values:
<C4,s2>_1, fanIn = 0 | <C2,s2>_3, fanIn = 0 | <C0,s1>_5, fanIn = 0 | <C2,s1>_7, fanIn = 0 | <C4,s1>_9, fanIn = 0 | <C6,s1>_11, fanIn = 0 | <C8,s1>_13, fanIn = 0 | <C0,s0>_15, fanIn = 0 | <C1,s0>_15, fanIn = 0 | <C2,s0>_15, fanIn = 0 | <C3,s0>_15, fanIn = 0 | <C4,s0>_15, fanIn = 0 | <C5,s0>_15, fanIn = 0 | <C6,s0>_15, fanIn = 0 | <C7,s0>_15, fanIn = 0 | <C8,s0>_15, fanIn = 0 | <C9,s0>_15, fanIn = 0 | <C9,s1>_14, fanIn = 1 | <C7,s1>_12, fanIn = 0 | <C5,s1>_10, fanIn = 0 | <C3,s1>_8, fanIn = 0 | <C1,s1>_6, fanIn = 0 | <C1,s2>_4, fanIn = 0 | <C3,s2>_2, fanIn = 0 | <C5,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 16 CYCLE execution nr. 4 ----------------
node to be examined: <C9,s1>_15
<C9,s1>_15 is NOT an initial node => need to look for parent
<C9,s1>_14 chosen with max fanIn value
origin node chosen: <C9,s1>_14
Update fanIn : fanIn[<C9,s1>_14] <- 0 (due to provide p9_1)
current generation: Generation nr.16: <C9,s1>_15; <C7,s1>_13; <C6,s2>; <C8,s1>_14
next working set, at level nr.15 : { <C9,s1>_14 <C7,s1>_12 <C5,s2> <C6,s1>_11 <C8,s1>_13  }
Nodes with fanIn values:
<C4,s2>_1, fanIn = 0 | <C2,s2>_3, fanIn = 0 | <C0,s1>_5, fanIn = 0 | <C2,s1>_7, fanIn = 0 | <C4,s1>_9, fanIn = 0 | <C6,s1>_11, fanIn = 0 | <C8,s1>_13, fanIn = 0 | <C0,s0>_15, fanIn = 0 | <C1,s0>_15, fanIn = 0 | <C2,s0>_15, fanIn = 0 | <C3,s0>_15, fanIn = 0 | <C4,s0>_15, fanIn = 0 | <C5,s0>_15, fanIn = 0 | <C6,s0>_15, fanIn = 0 | <C7,s0>_15, fanIn = 0 | <C8,s0>_15, fanIn = 0 | <C9,s0>_15, fanIn = 0 | <C9,s1>_14, fanIn = 0 | <C7,s1>_12, fanIn = 0 | <C5,s1>_10, fanIn = 0 | <C3,s1>_8, fanIn = 0 | <C1,s1>_6, fanIn = 0 | <C1,s2>_4, fanIn = 0 | <C3,s2>_2, fanIn = 0 | <C5,s2>, fanIn = 1
Total requires: p8_1 | p4_2 | p6_1 | p7_1 | p9_1
fanIn[<C3,s2>_1] := 0
fanIn[<C1,s2>_3] := 0
fanIn[<C1,s1>_5] := 0
fanIn[<C3,s1>_7] := 0
fanIn[<C5,s1>_9] := 0
fanIn[<C7,s1>_11] := 1
fanIn[<C9,s1>_13] := 1
fanIn[<C9,s0>_14] := 0
fanIn[<C8,s0>_14] := 0
fanIn[<C7,s0>_14] := 0
fanIn[<C6,s0>_14] := 0
fanIn[<C5,s0>_14] := 0
fanIn[<C4,s0>_14] := 0
fanIn[<C3,s0>_14] := 0
fanIn[<C2,s0>_14] := 0
fanIn[<C1,s0>_14] := 0
fanIn[<C0,s0>_14] := 0
fanIn[<C8,s1>_12] := 1
fanIn[<C6,s1>_10] := 1
fanIn[<C4,s1>_8] := 0
fanIn[<C2,s1>_6] := 0
fanIn[<C0,s1>_4] := 0
fanIn[<C2,s2>_2] := 0
fanIn[<C4,s2>] := 1
Nodes with fanIn values:
<C3,s2>_1, fanIn = 0 | <C1,s2>_3, fanIn = 0 | <C1,s1>_5, fanIn = 0 | <C3,s1>_7, fanIn = 0 | <C5,s1>_9, fanIn = 0 | <C7,s1>_11, fanIn = 1 | <C9,s1>_13, fanIn = 1 | <C9,s0>_14, fanIn = 0 | <C8,s0>_14, fanIn = 0 | <C7,s0>_14, fanIn = 0 | <C6,s0>_14, fanIn = 0 | <C5,s0>_14, fanIn = 0 | <C4,s0>_14, fanIn = 0 | <C3,s0>_14, fanIn = 0 | <C2,s0>_14, fanIn = 0 | <C1,s0>_14, fanIn = 0 | <C0,s0>_14, fanIn = 0 | <C8,s1>_12, fanIn = 1 | <C6,s1>_10, fanIn = 1 | <C4,s1>_8, fanIn = 0 | <C2,s1>_6, fanIn = 0 | <C0,s1>_4, fanIn = 0 | <C2,s2>_2, fanIn = 0 | <C4,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 15 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_14
<C9,s1>_14 is NOT an initial node => need to look for parent
<C9,s1>_13 chosen with max fanIn value
origin node chosen: <C9,s1>_13
Update fanIn : fanIn[<C9,s1>_13] <- 0 (due to provide p9_1)
current generation: Generation nr.15: <C9,s1>_14
next working set, at level nr.14 : { <C9,s1>_13  }
Nodes with fanIn values:
<C3,s2>_1, fanIn = 0 | <C1,s2>_3, fanIn = 0 | <C1,s1>_5, fanIn = 0 | <C3,s1>_7, fanIn = 0 | <C5,s1>_9, fanIn = 0 | <C7,s1>_11, fanIn = 1 | <C9,s1>_13, fanIn = 0 | <C9,s0>_14, fanIn = 0 | <C8,s0>_14, fanIn = 0 | <C7,s0>_14, fanIn = 0 | <C6,s0>_14, fanIn = 0 | <C5,s0>_14, fanIn = 0 | <C4,s0>_14, fanIn = 0 | <C3,s0>_14, fanIn = 0 | <C2,s0>_14, fanIn = 0 | <C1,s0>_14, fanIn = 0 | <C0,s0>_14, fanIn = 0 | <C8,s1>_12, fanIn = 1 | <C6,s1>_10, fanIn = 1 | <C4,s1>_8, fanIn = 0 | <C2,s1>_6, fanIn = 0 | <C0,s1>_4, fanIn = 0 | <C2,s2>_2, fanIn = 0 | <C4,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 15 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s1>_12
<C7,s1>_12 is NOT an initial node => need to look for parent
<C7,s1>_11 chosen with max fanIn value
origin node chosen: <C7,s1>_11
Update fanIn : fanIn[<C7,s1>_11] <- 0 (due to provide p7_1)
current generation: Generation nr.15: <C7,s1>_12; <C9,s1>_14
next working set, at level nr.14 : { <C7,s1>_11 <C9,s1>_13  }
Nodes with fanIn values:
<C3,s2>_1, fanIn = 0 | <C1,s2>_3, fanIn = 0 | <C1,s1>_5, fanIn = 0 | <C3,s1>_7, fanIn = 0 | <C5,s1>_9, fanIn = 0 | <C7,s1>_11, fanIn = 0 | <C9,s1>_13, fanIn = 0 | <C9,s0>_14, fanIn = 0 | <C8,s0>_14, fanIn = 0 | <C7,s0>_14, fanIn = 0 | <C6,s0>_14, fanIn = 0 | <C5,s0>_14, fanIn = 0 | <C4,s0>_14, fanIn = 0 | <C3,s0>_14, fanIn = 0 | <C2,s0>_14, fanIn = 0 | <C1,s0>_14, fanIn = 0 | <C0,s0>_14, fanIn = 0 | <C8,s1>_12, fanIn = 1 | <C6,s1>_10, fanIn = 1 | <C4,s1>_8, fanIn = 0 | <C2,s1>_6, fanIn = 0 | <C0,s1>_4, fanIn = 0 | <C2,s2>_2, fanIn = 0 | <C4,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 15 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s2>
<C5,s2> is NOT an initial node => need to look for parent
<C5,s1>_9 chosen with max fanIn value
origin node chosen: <C5,s1>_9
<C5,s2> is NOT a copy => must take care of providers
list of chosen providers: <C4,s2> <C6,s1>_10 
current generation: Generation nr.15: <C5,s2>; <C7,s1>_12; <C9,s1>_14
next working set, at level nr.14 : { <C4,s2> <C6,s1>_10 <C5,s1>_9 <C7,s1>_11 <C9,s1>_13  }
Nodes with fanIn values:
<C3,s2>_1, fanIn = 0 | <C1,s2>_3, fanIn = 0 | <C1,s1>_5, fanIn = 0 | <C3,s1>_7, fanIn = 0 | <C5,s1>_9, fanIn = 0 | <C7,s1>_11, fanIn = 0 | <C9,s1>_13, fanIn = 0 | <C9,s0>_14, fanIn = 0 | <C8,s0>_14, fanIn = 0 | <C7,s0>_14, fanIn = 0 | <C6,s0>_14, fanIn = 0 | <C5,s0>_14, fanIn = 0 | <C4,s0>_14, fanIn = 0 | <C3,s0>_14, fanIn = 0 | <C2,s0>_14, fanIn = 0 | <C1,s0>_14, fanIn = 0 | <C0,s0>_14, fanIn = 0 | <C8,s1>_12, fanIn = 1 | <C6,s1>_10, fanIn = 1 | <C4,s1>_8, fanIn = 0 | <C2,s1>_6, fanIn = 0 | <C0,s1>_4, fanIn = 0 | <C2,s2>_2, fanIn = 0 | <C4,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 15 CYCLE execution nr. 4 ----------------
node to be examined: <C6,s1>_11
<C6,s1>_11 is NOT an initial node => need to look for parent
<C6,s1>_10 chosen with max fanIn value
origin node chosen: <C6,s1>_10
Update fanIn : fanIn[<C6,s1>_10] <- 0 (due to provide p6_1)
current generation: Generation nr.15: <C6,s1>_11; <C5,s2>; <C7,s1>_12; <C9,s1>_14
next working set, at level nr.14 : { <C6,s1>_10 <C4,s2> <C5,s1>_9 <C7,s1>_11 <C9,s1>_13  }
Nodes with fanIn values:
<C3,s2>_1, fanIn = 0 | <C1,s2>_3, fanIn = 0 | <C1,s1>_5, fanIn = 0 | <C3,s1>_7, fanIn = 0 | <C5,s1>_9, fanIn = 0 | <C7,s1>_11, fanIn = 0 | <C9,s1>_13, fanIn = 0 | <C9,s0>_14, fanIn = 0 | <C8,s0>_14, fanIn = 0 | <C7,s0>_14, fanIn = 0 | <C6,s0>_14, fanIn = 0 | <C5,s0>_14, fanIn = 0 | <C4,s0>_14, fanIn = 0 | <C3,s0>_14, fanIn = 0 | <C2,s0>_14, fanIn = 0 | <C1,s0>_14, fanIn = 0 | <C0,s0>_14, fanIn = 0 | <C8,s1>_12, fanIn = 1 | <C6,s1>_10, fanIn = 0 | <C4,s1>_8, fanIn = 0 | <C2,s1>_6, fanIn = 0 | <C0,s1>_4, fanIn = 0 | <C2,s2>_2, fanIn = 0 | <C4,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 15 CYCLE execution nr. 5 ----------------
node to be examined: <C8,s1>_13
<C8,s1>_13 is NOT an initial node => need to look for parent
<C8,s1>_12 chosen with max fanIn value
origin node chosen: <C8,s1>_12
Update fanIn : fanIn[<C8,s1>_12] <- 0 (due to provide p8_1)
current generation: Generation nr.15: <C8,s1>_13; <C6,s1>_11; <C5,s2>; <C7,s1>_12; <C9,s1>_14
next working set, at level nr.14 : { <C8,s1>_12 <C6,s1>_10 <C4,s2> <C5,s1>_9 <C7,s1>_11 <C9,s1>_13  }
Nodes with fanIn values:
<C3,s2>_1, fanIn = 0 | <C1,s2>_3, fanIn = 0 | <C1,s1>_5, fanIn = 0 | <C3,s1>_7, fanIn = 0 | <C5,s1>_9, fanIn = 0 | <C7,s1>_11, fanIn = 0 | <C9,s1>_13, fanIn = 0 | <C9,s0>_14, fanIn = 0 | <C8,s0>_14, fanIn = 0 | <C7,s0>_14, fanIn = 0 | <C6,s0>_14, fanIn = 0 | <C5,s0>_14, fanIn = 0 | <C4,s0>_14, fanIn = 0 | <C3,s0>_14, fanIn = 0 | <C2,s0>_14, fanIn = 0 | <C1,s0>_14, fanIn = 0 | <C0,s0>_14, fanIn = 0 | <C8,s1>_12, fanIn = 0 | <C6,s1>_10, fanIn = 0 | <C4,s1>_8, fanIn = 0 | <C2,s1>_6, fanIn = 0 | <C0,s1>_4, fanIn = 0 | <C2,s2>_2, fanIn = 0 | <C4,s2>, fanIn = 1
Total requires: p9_1 | p7_1 | p3_2 | p5_1 | p6_1 | p8_1
fanIn[<C2,s2>_1] := 0
fanIn[<C0,s1>_3] := 0
fanIn[<C2,s1>_5] := 0
fanIn[<C4,s1>_7] := 0
fanIn[<C6,s1>_9] := 1
fanIn[<C8,s1>_11] := 1
fanIn[<C0,s0>_13] := 0
fanIn[<C1,s0>_13] := 0
fanIn[<C2,s0>_13] := 0
fanIn[<C3,s0>_13] := 0
fanIn[<C4,s0>_13] := 0
fanIn[<C5,s0>_13] := 0
fanIn[<C6,s0>_13] := 0
fanIn[<C7,s0>_13] := 0
fanIn[<C8,s0>_13] := 0
fanIn[<C9,s0>_13] := 0
fanIn[<C9,s1>_12] := 1
fanIn[<C7,s1>_10] := 1
fanIn[<C5,s1>_8] := 1
fanIn[<C3,s1>_6] := 0
fanIn[<C1,s1>_4] := 0
fanIn[<C1,s2>_2] := 0
fanIn[<C3,s2>] := 1
Nodes with fanIn values:
<C2,s2>_1, fanIn = 0 | <C0,s1>_3, fanIn = 0 | <C2,s1>_5, fanIn = 0 | <C4,s1>_7, fanIn = 0 | <C6,s1>_9, fanIn = 1 | <C8,s1>_11, fanIn = 1 | <C0,s0>_13, fanIn = 0 | <C1,s0>_13, fanIn = 0 | <C2,s0>_13, fanIn = 0 | <C3,s0>_13, fanIn = 0 | <C4,s0>_13, fanIn = 0 | <C5,s0>_13, fanIn = 0 | <C6,s0>_13, fanIn = 0 | <C7,s0>_13, fanIn = 0 | <C8,s0>_13, fanIn = 0 | <C9,s0>_13, fanIn = 0 | <C9,s1>_12, fanIn = 1 | <C7,s1>_10, fanIn = 1 | <C5,s1>_8, fanIn = 1 | <C3,s1>_6, fanIn = 0 | <C1,s1>_4, fanIn = 0 | <C1,s2>_2, fanIn = 0 | <C3,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>_12
<C8,s1>_12 is NOT an initial node => need to look for parent
<C8,s1>_11 chosen with max fanIn value
origin node chosen: <C8,s1>_11
Update fanIn : fanIn[<C8,s1>_11] <- 0 (due to provide p8_1)
current generation: Generation nr.14: <C8,s1>_12
next working set, at level nr.13 : { <C8,s1>_11  }
Nodes with fanIn values:
<C2,s2>_1, fanIn = 0 | <C0,s1>_3, fanIn = 0 | <C2,s1>_5, fanIn = 0 | <C4,s1>_7, fanIn = 0 | <C6,s1>_9, fanIn = 1 | <C8,s1>_11, fanIn = 0 | <C0,s0>_13, fanIn = 0 | <C1,s0>_13, fanIn = 0 | <C2,s0>_13, fanIn = 0 | <C3,s0>_13, fanIn = 0 | <C4,s0>_13, fanIn = 0 | <C5,s0>_13, fanIn = 0 | <C6,s0>_13, fanIn = 0 | <C7,s0>_13, fanIn = 0 | <C8,s0>_13, fanIn = 0 | <C9,s0>_13, fanIn = 0 | <C9,s1>_12, fanIn = 1 | <C7,s1>_10, fanIn = 1 | <C5,s1>_8, fanIn = 1 | <C3,s1>_6, fanIn = 0 | <C1,s1>_4, fanIn = 0 | <C1,s2>_2, fanIn = 0 | <C3,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s1>_10
<C6,s1>_10 is NOT an initial node => need to look for parent
<C6,s1>_9 chosen with max fanIn value
origin node chosen: <C6,s1>_9
Update fanIn : fanIn[<C6,s1>_9] <- 0 (due to provide p6_1)
current generation: Generation nr.14: <C6,s1>_10; <C8,s1>_12
next working set, at level nr.13 : { <C6,s1>_9 <C8,s1>_11  }
Nodes with fanIn values:
<C2,s2>_1, fanIn = 0 | <C0,s1>_3, fanIn = 0 | <C2,s1>_5, fanIn = 0 | <C4,s1>_7, fanIn = 0 | <C6,s1>_9, fanIn = 0 | <C8,s1>_11, fanIn = 0 | <C0,s0>_13, fanIn = 0 | <C1,s0>_13, fanIn = 0 | <C2,s0>_13, fanIn = 0 | <C3,s0>_13, fanIn = 0 | <C4,s0>_13, fanIn = 0 | <C5,s0>_13, fanIn = 0 | <C6,s0>_13, fanIn = 0 | <C7,s0>_13, fanIn = 0 | <C8,s0>_13, fanIn = 0 | <C9,s0>_13, fanIn = 0 | <C9,s1>_12, fanIn = 1 | <C7,s1>_10, fanIn = 1 | <C5,s1>_8, fanIn = 1 | <C3,s1>_6, fanIn = 0 | <C1,s1>_4, fanIn = 0 | <C1,s2>_2, fanIn = 0 | <C3,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 3 ----------------
node to be examined: <C4,s2>
<C4,s2> is NOT an initial node => need to look for parent
<C4,s1>_7 chosen with max fanIn value
origin node chosen: <C4,s1>_7
<C4,s2> is NOT a copy => must take care of providers
list of chosen providers: <C3,s2> <C5,s1>_8 
current generation: Generation nr.14: <C4,s2>; <C6,s1>_10; <C8,s1>_12
next working set, at level nr.13 : { <C3,s2> <C5,s1>_8 <C4,s1>_7 <C6,s1>_9 <C8,s1>_11  }
Nodes with fanIn values:
<C2,s2>_1, fanIn = 0 | <C0,s1>_3, fanIn = 0 | <C2,s1>_5, fanIn = 0 | <C4,s1>_7, fanIn = 0 | <C6,s1>_9, fanIn = 0 | <C8,s1>_11, fanIn = 0 | <C0,s0>_13, fanIn = 0 | <C1,s0>_13, fanIn = 0 | <C2,s0>_13, fanIn = 0 | <C3,s0>_13, fanIn = 0 | <C4,s0>_13, fanIn = 0 | <C5,s0>_13, fanIn = 0 | <C6,s0>_13, fanIn = 0 | <C7,s0>_13, fanIn = 0 | <C8,s0>_13, fanIn = 0 | <C9,s0>_13, fanIn = 0 | <C9,s1>_12, fanIn = 1 | <C7,s1>_10, fanIn = 1 | <C5,s1>_8, fanIn = 1 | <C3,s1>_6, fanIn = 0 | <C1,s1>_4, fanIn = 0 | <C1,s2>_2, fanIn = 0 | <C3,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 4 ----------------
node to be examined: <C5,s1>_9
<C5,s1>_9 is NOT an initial node => need to look for parent
<C5,s1>_8 chosen with max fanIn value
origin node chosen: <C5,s1>_8
Update fanIn : fanIn[<C5,s1>_8] <- 0 (due to provide p5_1)
current generation: Generation nr.14: <C5,s1>_9; <C4,s2>; <C6,s1>_10; <C8,s1>_12
next working set, at level nr.13 : { <C5,s1>_8 <C3,s2> <C4,s1>_7 <C6,s1>_9 <C8,s1>_11  }
Nodes with fanIn values:
<C2,s2>_1, fanIn = 0 | <C0,s1>_3, fanIn = 0 | <C2,s1>_5, fanIn = 0 | <C4,s1>_7, fanIn = 0 | <C6,s1>_9, fanIn = 0 | <C8,s1>_11, fanIn = 0 | <C0,s0>_13, fanIn = 0 | <C1,s0>_13, fanIn = 0 | <C2,s0>_13, fanIn = 0 | <C3,s0>_13, fanIn = 0 | <C4,s0>_13, fanIn = 0 | <C5,s0>_13, fanIn = 0 | <C6,s0>_13, fanIn = 0 | <C7,s0>_13, fanIn = 0 | <C8,s0>_13, fanIn = 0 | <C9,s0>_13, fanIn = 0 | <C9,s1>_12, fanIn = 1 | <C7,s1>_10, fanIn = 1 | <C5,s1>_8, fanIn = 0 | <C3,s1>_6, fanIn = 0 | <C1,s1>_4, fanIn = 0 | <C1,s2>_2, fanIn = 0 | <C3,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 5 ----------------
node to be examined: <C7,s1>_11
<C7,s1>_11 is NOT an initial node => need to look for parent
<C7,s1>_10 chosen with max fanIn value
origin node chosen: <C7,s1>_10
Update fanIn : fanIn[<C7,s1>_10] <- 0 (due to provide p7_1)
current generation: Generation nr.14: <C7,s1>_11; <C5,s1>_9; <C4,s2>; <C6,s1>_10; <C8,s1>_12
next working set, at level nr.13 : { <C7,s1>_10 <C5,s1>_8 <C3,s2> <C4,s1>_7 <C6,s1>_9 <C8,s1>_11  }
Nodes with fanIn values:
<C2,s2>_1, fanIn = 0 | <C0,s1>_3, fanIn = 0 | <C2,s1>_5, fanIn = 0 | <C4,s1>_7, fanIn = 0 | <C6,s1>_9, fanIn = 0 | <C8,s1>_11, fanIn = 0 | <C0,s0>_13, fanIn = 0 | <C1,s0>_13, fanIn = 0 | <C2,s0>_13, fanIn = 0 | <C3,s0>_13, fanIn = 0 | <C4,s0>_13, fanIn = 0 | <C5,s0>_13, fanIn = 0 | <C6,s0>_13, fanIn = 0 | <C7,s0>_13, fanIn = 0 | <C8,s0>_13, fanIn = 0 | <C9,s0>_13, fanIn = 0 | <C9,s1>_12, fanIn = 1 | <C7,s1>_10, fanIn = 0 | <C5,s1>_8, fanIn = 0 | <C3,s1>_6, fanIn = 0 | <C1,s1>_4, fanIn = 0 | <C1,s2>_2, fanIn = 0 | <C3,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 6 ----------------
node to be examined: <C9,s1>_13
<C9,s1>_13 is NOT an initial node => need to look for parent
<C9,s1>_12 chosen with max fanIn value
origin node chosen: <C9,s1>_12
Update fanIn : fanIn[<C9,s1>_12] <- 0 (due to provide p9_1)
current generation: Generation nr.14: <C9,s1>_13; <C7,s1>_11; <C5,s1>_9; <C4,s2>; <C6,s1>_10; <C8,s1>_12
next working set, at level nr.13 : { <C9,s1>_12 <C7,s1>_10 <C5,s1>_8 <C3,s2> <C4,s1>_7 <C6,s1>_9 <C8,s1>_11  }
Nodes with fanIn values:
<C2,s2>_1, fanIn = 0 | <C0,s1>_3, fanIn = 0 | <C2,s1>_5, fanIn = 0 | <C4,s1>_7, fanIn = 0 | <C6,s1>_9, fanIn = 0 | <C8,s1>_11, fanIn = 0 | <C0,s0>_13, fanIn = 0 | <C1,s0>_13, fanIn = 0 | <C2,s0>_13, fanIn = 0 | <C3,s0>_13, fanIn = 0 | <C4,s0>_13, fanIn = 0 | <C5,s0>_13, fanIn = 0 | <C6,s0>_13, fanIn = 0 | <C7,s0>_13, fanIn = 0 | <C8,s0>_13, fanIn = 0 | <C9,s0>_13, fanIn = 0 | <C9,s1>_12, fanIn = 0 | <C7,s1>_10, fanIn = 0 | <C5,s1>_8, fanIn = 0 | <C3,s1>_6, fanIn = 0 | <C1,s1>_4, fanIn = 0 | <C1,s2>_2, fanIn = 0 | <C3,s2>, fanIn = 1
Total requires: p8_1 | p6_1 | p2_2 | p4_1 | p5_1 | p7_1 | p9_1
fanIn[<C1,s2>_1] := 0
fanIn[<C1,s1>_3] := 0
fanIn[<C3,s1>_5] := 0
fanIn[<C5,s1>_7] := 1
fanIn[<C7,s1>_9] := 1
fanIn[<C9,s1>_11] := 1
fanIn[<C9,s0>_12] := 0
fanIn[<C8,s0>_12] := 0
fanIn[<C7,s0>_12] := 0
fanIn[<C6,s0>_12] := 0
fanIn[<C5,s0>_12] := 0
fanIn[<C4,s0>_12] := 0
fanIn[<C3,s0>_12] := 0
fanIn[<C2,s0>_12] := 0
fanIn[<C1,s0>_12] := 0
fanIn[<C0,s0>_12] := 0
fanIn[<C8,s1>_10] := 1
fanIn[<C6,s1>_8] := 1
fanIn[<C4,s1>_6] := 1
fanIn[<C2,s1>_4] := 0
fanIn[<C0,s1>_2] := 0
fanIn[<C2,s2>] := 1
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 1 | <C7,s1>_9, fanIn = 1 | <C9,s1>_11, fanIn = 1 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 1 | <C6,s1>_8, fanIn = 1 | <C4,s1>_6, fanIn = 1 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_12
<C9,s1>_12 is NOT an initial node => need to look for parent
<C9,s1>_11 chosen with max fanIn value
origin node chosen: <C9,s1>_11
Update fanIn : fanIn[<C9,s1>_11] <- 0 (due to provide p9_1)
current generation: Generation nr.13: <C9,s1>_12
next working set, at level nr.12 : { <C9,s1>_11  }
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 1 | <C7,s1>_9, fanIn = 1 | <C9,s1>_11, fanIn = 0 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 1 | <C6,s1>_8, fanIn = 1 | <C4,s1>_6, fanIn = 1 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s1>_10
<C7,s1>_10 is NOT an initial node => need to look for parent
<C7,s1>_9 chosen with max fanIn value
origin node chosen: <C7,s1>_9
Update fanIn : fanIn[<C7,s1>_9] <- 0 (due to provide p7_1)
current generation: Generation nr.13: <C7,s1>_10; <C9,s1>_12
next working set, at level nr.12 : { <C7,s1>_9 <C9,s1>_11  }
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 1 | <C7,s1>_9, fanIn = 0 | <C9,s1>_11, fanIn = 0 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 1 | <C6,s1>_8, fanIn = 1 | <C4,s1>_6, fanIn = 1 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s1>_8
<C5,s1>_8 is NOT an initial node => need to look for parent
<C5,s1>_7 chosen with max fanIn value
origin node chosen: <C5,s1>_7
Update fanIn : fanIn[<C5,s1>_7] <- 0 (due to provide p5_1)
current generation: Generation nr.13: <C5,s1>_8; <C7,s1>_10; <C9,s1>_12
next working set, at level nr.12 : { <C5,s1>_7 <C7,s1>_9 <C9,s1>_11  }
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 0 | <C7,s1>_9, fanIn = 0 | <C9,s1>_11, fanIn = 0 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 1 | <C6,s1>_8, fanIn = 1 | <C4,s1>_6, fanIn = 1 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 4 ----------------
node to be examined: <C3,s2>
<C3,s2> is NOT an initial node => need to look for parent
<C3,s1>_5 chosen with max fanIn value
origin node chosen: <C3,s1>_5
<C3,s2> is NOT a copy => must take care of providers
list of chosen providers: <C2,s2> <C4,s1>_6 
current generation: Generation nr.13: <C3,s2>; <C5,s1>_8; <C7,s1>_10; <C9,s1>_12
next working set, at level nr.12 : { <C2,s2> <C4,s1>_6 <C3,s1>_5 <C5,s1>_7 <C7,s1>_9 <C9,s1>_11  }
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 0 | <C7,s1>_9, fanIn = 0 | <C9,s1>_11, fanIn = 0 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 1 | <C6,s1>_8, fanIn = 1 | <C4,s1>_6, fanIn = 1 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 5 ----------------
node to be examined: <C4,s1>_7
<C4,s1>_7 is NOT an initial node => need to look for parent
<C4,s1>_6 chosen with max fanIn value
origin node chosen: <C4,s1>_6
Update fanIn : fanIn[<C4,s1>_6] <- 0 (due to provide p4_1)
current generation: Generation nr.13: <C4,s1>_7; <C3,s2>; <C5,s1>_8; <C7,s1>_10; <C9,s1>_12
next working set, at level nr.12 : { <C4,s1>_6 <C2,s2> <C3,s1>_5 <C5,s1>_7 <C7,s1>_9 <C9,s1>_11  }
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 0 | <C7,s1>_9, fanIn = 0 | <C9,s1>_11, fanIn = 0 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 1 | <C6,s1>_8, fanIn = 1 | <C4,s1>_6, fanIn = 0 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 6 ----------------
node to be examined: <C6,s1>_9
<C6,s1>_9 is NOT an initial node => need to look for parent
<C6,s1>_8 chosen with max fanIn value
origin node chosen: <C6,s1>_8
Update fanIn : fanIn[<C6,s1>_8] <- 0 (due to provide p6_1)
current generation: Generation nr.13: <C6,s1>_9; <C4,s1>_7; <C3,s2>; <C5,s1>_8; <C7,s1>_10; <C9,s1>_12
next working set, at level nr.12 : { <C6,s1>_8 <C4,s1>_6 <C2,s2> <C3,s1>_5 <C5,s1>_7 <C7,s1>_9 <C9,s1>_11  }
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 0 | <C7,s1>_9, fanIn = 0 | <C9,s1>_11, fanIn = 0 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 1 | <C6,s1>_8, fanIn = 0 | <C4,s1>_6, fanIn = 0 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 7 ----------------
node to be examined: <C8,s1>_11
<C8,s1>_11 is NOT an initial node => need to look for parent
<C8,s1>_10 chosen with max fanIn value
origin node chosen: <C8,s1>_10
Update fanIn : fanIn[<C8,s1>_10] <- 0 (due to provide p8_1)
current generation: Generation nr.13: <C8,s1>_11; <C6,s1>_9; <C4,s1>_7; <C3,s2>; <C5,s1>_8; <C7,s1>_10; <C9,s1>_12
next working set, at level nr.12 : { <C8,s1>_10 <C6,s1>_8 <C4,s1>_6 <C2,s2> <C3,s1>_5 <C5,s1>_7 <C7,s1>_9 <C9,s1>_11  }
Nodes with fanIn values:
<C1,s2>_1, fanIn = 0 | <C1,s1>_3, fanIn = 0 | <C3,s1>_5, fanIn = 0 | <C5,s1>_7, fanIn = 0 | <C7,s1>_9, fanIn = 0 | <C9,s1>_11, fanIn = 0 | <C9,s0>_12, fanIn = 0 | <C8,s0>_12, fanIn = 0 | <C7,s0>_12, fanIn = 0 | <C6,s0>_12, fanIn = 0 | <C5,s0>_12, fanIn = 0 | <C4,s0>_12, fanIn = 0 | <C3,s0>_12, fanIn = 0 | <C2,s0>_12, fanIn = 0 | <C1,s0>_12, fanIn = 0 | <C0,s0>_12, fanIn = 0 | <C8,s1>_10, fanIn = 0 | <C6,s1>_8, fanIn = 0 | <C4,s1>_6, fanIn = 0 | <C2,s1>_4, fanIn = 0 | <C0,s1>_2, fanIn = 0 | <C2,s2>, fanIn = 1
Total requires: p9_1 | p7_1 | p5_1 | p1_2 | p3_1 | p4_1 | p6_1 | p8_1
fanIn[<C0,s1>_1] := 0
fanIn[<C2,s1>_3] := 0
fanIn[<C4,s1>_5] := 1
fanIn[<C6,s1>_7] := 1
fanIn[<C8,s1>_9] := 1
fanIn[<C0,s0>_11] := 0
fanIn[<C1,s0>_11] := 0
fanIn[<C2,s0>_11] := 0
fanIn[<C3,s0>_11] := 0
fanIn[<C4,s0>_11] := 0
fanIn[<C5,s0>_11] := 0
fanIn[<C6,s0>_11] := 0
fanIn[<C7,s0>_11] := 0
fanIn[<C8,s0>_11] := 0
fanIn[<C9,s0>_11] := 0
fanIn[<C9,s1>_10] := 1
fanIn[<C7,s1>_8] := 1
fanIn[<C5,s1>_6] := 1
fanIn[<C3,s1>_4] := 1
fanIn[<C1,s1>_2] := 0
fanIn[<C1,s2>] := 1
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 1 | <C6,s1>_7, fanIn = 1 | <C8,s1>_9, fanIn = 1 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 1 | <C5,s1>_6, fanIn = 1 | <C3,s1>_4, fanIn = 1 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>_10
<C8,s1>_10 is NOT an initial node => need to look for parent
<C8,s1>_9 chosen with max fanIn value
origin node chosen: <C8,s1>_9
Update fanIn : fanIn[<C8,s1>_9] <- 0 (due to provide p8_1)
current generation: Generation nr.12: <C8,s1>_10
next working set, at level nr.11 : { <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 1 | <C6,s1>_7, fanIn = 1 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 1 | <C5,s1>_6, fanIn = 1 | <C3,s1>_4, fanIn = 1 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s1>_8
<C6,s1>_8 is NOT an initial node => need to look for parent
<C6,s1>_7 chosen with max fanIn value
origin node chosen: <C6,s1>_7
Update fanIn : fanIn[<C6,s1>_7] <- 0 (due to provide p6_1)
current generation: Generation nr.12: <C6,s1>_8; <C8,s1>_10
next working set, at level nr.11 : { <C6,s1>_7 <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 1 | <C6,s1>_7, fanIn = 0 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 1 | <C5,s1>_6, fanIn = 1 | <C3,s1>_4, fanIn = 1 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 3 ----------------
node to be examined: <C4,s1>_6
<C4,s1>_6 is NOT an initial node => need to look for parent
<C4,s1>_5 chosen with max fanIn value
origin node chosen: <C4,s1>_5
Update fanIn : fanIn[<C4,s1>_5] <- 0 (due to provide p4_1)
current generation: Generation nr.12: <C4,s1>_6; <C6,s1>_8; <C8,s1>_10
next working set, at level nr.11 : { <C4,s1>_5 <C6,s1>_7 <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 0 | <C6,s1>_7, fanIn = 0 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 1 | <C5,s1>_6, fanIn = 1 | <C3,s1>_4, fanIn = 1 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 4 ----------------
node to be examined: <C2,s2>
<C2,s2> is NOT an initial node => need to look for parent
<C2,s1>_3 chosen with max fanIn value
origin node chosen: <C2,s1>_3
<C2,s2> is NOT a copy => must take care of providers
list of chosen providers: <C1,s2> <C3,s1>_4 
current generation: Generation nr.12: <C2,s2>; <C4,s1>_6; <C6,s1>_8; <C8,s1>_10
next working set, at level nr.11 : { <C1,s2> <C3,s1>_4 <C2,s1>_3 <C4,s1>_5 <C6,s1>_7 <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 0 | <C6,s1>_7, fanIn = 0 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 1 | <C5,s1>_6, fanIn = 1 | <C3,s1>_4, fanIn = 1 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 5 ----------------
node to be examined: <C3,s1>_5
<C3,s1>_5 is NOT an initial node => need to look for parent
<C3,s1>_4 chosen with max fanIn value
origin node chosen: <C3,s1>_4
Update fanIn : fanIn[<C3,s1>_4] <- 0 (due to provide p3_1)
current generation: Generation nr.12: <C3,s1>_5; <C2,s2>; <C4,s1>_6; <C6,s1>_8; <C8,s1>_10
next working set, at level nr.11 : { <C3,s1>_4 <C1,s2> <C2,s1>_3 <C4,s1>_5 <C6,s1>_7 <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 0 | <C6,s1>_7, fanIn = 0 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 1 | <C5,s1>_6, fanIn = 1 | <C3,s1>_4, fanIn = 0 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 6 ----------------
node to be examined: <C5,s1>_7
<C5,s1>_7 is NOT an initial node => need to look for parent
<C5,s1>_6 chosen with max fanIn value
origin node chosen: <C5,s1>_6
Update fanIn : fanIn[<C5,s1>_6] <- 0 (due to provide p5_1)
current generation: Generation nr.12: <C5,s1>_7; <C3,s1>_5; <C2,s2>; <C4,s1>_6; <C6,s1>_8; <C8,s1>_10
next working set, at level nr.11 : { <C5,s1>_6 <C3,s1>_4 <C1,s2> <C2,s1>_3 <C4,s1>_5 <C6,s1>_7 <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 0 | <C6,s1>_7, fanIn = 0 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 1 | <C5,s1>_6, fanIn = 0 | <C3,s1>_4, fanIn = 0 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 7 ----------------
node to be examined: <C7,s1>_9
<C7,s1>_9 is NOT an initial node => need to look for parent
<C7,s1>_8 chosen with max fanIn value
origin node chosen: <C7,s1>_8
Update fanIn : fanIn[<C7,s1>_8] <- 0 (due to provide p7_1)
current generation: Generation nr.12: <C7,s1>_9; <C5,s1>_7; <C3,s1>_5; <C2,s2>; <C4,s1>_6; <C6,s1>_8; <C8,s1>_10
next working set, at level nr.11 : { <C7,s1>_8 <C5,s1>_6 <C3,s1>_4 <C1,s2> <C2,s1>_3 <C4,s1>_5 <C6,s1>_7 <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 0 | <C6,s1>_7, fanIn = 0 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 1 | <C7,s1>_8, fanIn = 0 | <C5,s1>_6, fanIn = 0 | <C3,s1>_4, fanIn = 0 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 8 ----------------
node to be examined: <C9,s1>_11
<C9,s1>_11 is NOT an initial node => need to look for parent
<C9,s1>_10 chosen with max fanIn value
origin node chosen: <C9,s1>_10
Update fanIn : fanIn[<C9,s1>_10] <- 0 (due to provide p9_1)
current generation: Generation nr.12: <C9,s1>_11; <C7,s1>_9; <C5,s1>_7; <C3,s1>_5; <C2,s2>; <C4,s1>_6; <C6,s1>_8; <C8,s1>_10
next working set, at level nr.11 : { <C9,s1>_10 <C7,s1>_8 <C5,s1>_6 <C3,s1>_4 <C1,s2> <C2,s1>_3 <C4,s1>_5 <C6,s1>_7 <C8,s1>_9  }
Nodes with fanIn values:
<C0,s1>_1, fanIn = 0 | <C2,s1>_3, fanIn = 0 | <C4,s1>_5, fanIn = 0 | <C6,s1>_7, fanIn = 0 | <C8,s1>_9, fanIn = 0 | <C0,s0>_11, fanIn = 0 | <C1,s0>_11, fanIn = 0 | <C2,s0>_11, fanIn = 0 | <C3,s0>_11, fanIn = 0 | <C4,s0>_11, fanIn = 0 | <C5,s0>_11, fanIn = 0 | <C6,s0>_11, fanIn = 0 | <C7,s0>_11, fanIn = 0 | <C8,s0>_11, fanIn = 0 | <C9,s0>_11, fanIn = 0 | <C9,s1>_10, fanIn = 0 | <C7,s1>_8, fanIn = 0 | <C5,s1>_6, fanIn = 0 | <C3,s1>_4, fanIn = 0 | <C1,s1>_2, fanIn = 0 | <C1,s2>, fanIn = 1
Total requires: p8_1 | p6_1 | p4_1 | p0_2 | p2_1 | p3_1 | p5_1 | p7_1 | p9_1
fanIn[<C1,s1>_1] := 0
fanIn[<C3,s1>_3] := 1
fanIn[<C5,s1>_5] := 1
fanIn[<C7,s1>_7] := 1
fanIn[<C9,s1>_9] := 1
fanIn[<C9,s0>_10] := 0
fanIn[<C8,s0>_10] := 0
fanIn[<C7,s0>_10] := 0
fanIn[<C6,s0>_10] := 0
fanIn[<C5,s0>_10] := 0
fanIn[<C4,s0>_10] := 0
fanIn[<C3,s0>_10] := 0
fanIn[<C2,s0>_10] := 0
fanIn[<C1,s0>_10] := 0
fanIn[<C0,s0>_10] := 0
fanIn[<C8,s1>_8] := 1
fanIn[<C6,s1>_6] := 1
fanIn[<C4,s1>_4] := 1
fanIn[<C2,s1>_2] := 1
fanIn[<C0,s1>] := 1
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 1 | <C5,s1>_5, fanIn = 1 | <C7,s1>_7, fanIn = 1 | <C9,s1>_9, fanIn = 1 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 1 | <C2,s1>_2, fanIn = 1 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_10
<C9,s1>_10 is NOT an initial node => need to look for parent
<C9,s1>_9 chosen with max fanIn value
origin node chosen: <C9,s1>_9
Update fanIn : fanIn[<C9,s1>_9] <- 0 (due to provide p9_1)
current generation: Generation nr.11: <C9,s1>_10
next working set, at level nr.10 : { <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 1 | <C5,s1>_5, fanIn = 1 | <C7,s1>_7, fanIn = 1 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 1 | <C2,s1>_2, fanIn = 1 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s1>_8
<C7,s1>_8 is NOT an initial node => need to look for parent
<C7,s1>_7 chosen with max fanIn value
origin node chosen: <C7,s1>_7
Update fanIn : fanIn[<C7,s1>_7] <- 0 (due to provide p7_1)
current generation: Generation nr.11: <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 1 | <C5,s1>_5, fanIn = 1 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 1 | <C2,s1>_2, fanIn = 1 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s1>_6
<C5,s1>_6 is NOT an initial node => need to look for parent
<C5,s1>_5 chosen with max fanIn value
origin node chosen: <C5,s1>_5
Update fanIn : fanIn[<C5,s1>_5] <- 0 (due to provide p5_1)
current generation: Generation nr.11: <C5,s1>_6; <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C5,s1>_5 <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 1 | <C5,s1>_5, fanIn = 0 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 1 | <C2,s1>_2, fanIn = 1 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 4 ----------------
node to be examined: <C3,s1>_4
<C3,s1>_4 is NOT an initial node => need to look for parent
<C3,s1>_3 chosen with max fanIn value
origin node chosen: <C3,s1>_3
Update fanIn : fanIn[<C3,s1>_3] <- 0 (due to provide p3_1)
current generation: Generation nr.11: <C3,s1>_4; <C5,s1>_6; <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C3,s1>_3 <C5,s1>_5 <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 0 | <C5,s1>_5, fanIn = 0 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 1 | <C2,s1>_2, fanIn = 1 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 5 ----------------
node to be examined: <C1,s2>
<C1,s2> is NOT an initial node => need to look for parent
<C1,s1>_1 chosen with max fanIn value
origin node chosen: <C1,s1>_1
<C1,s2> is NOT a copy => must take care of providers
list of chosen providers: <C0,s1> <C2,s1>_2 
current generation: Generation nr.11: <C1,s2>; <C3,s1>_4; <C5,s1>_6; <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C0,s1> <C2,s1>_2 <C1,s1>_1 <C3,s1>_3 <C5,s1>_5 <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 0 | <C5,s1>_5, fanIn = 0 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 1 | <C2,s1>_2, fanIn = 1 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 6 ----------------
node to be examined: <C2,s1>_3
<C2,s1>_3 is NOT an initial node => need to look for parent
<C2,s1>_2 chosen with max fanIn value
origin node chosen: <C2,s1>_2
Update fanIn : fanIn[<C2,s1>_2] <- 0 (due to provide p2_1)
current generation: Generation nr.11: <C2,s1>_3; <C1,s2>; <C3,s1>_4; <C5,s1>_6; <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C2,s1>_2 <C0,s1> <C1,s1>_1 <C3,s1>_3 <C5,s1>_5 <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 0 | <C5,s1>_5, fanIn = 0 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 1 | <C2,s1>_2, fanIn = 0 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 7 ----------------
node to be examined: <C4,s1>_5
<C4,s1>_5 is NOT an initial node => need to look for parent
<C4,s1>_4 chosen with max fanIn value
origin node chosen: <C4,s1>_4
Update fanIn : fanIn[<C4,s1>_4] <- 0 (due to provide p4_1)
current generation: Generation nr.11: <C4,s1>_5; <C2,s1>_3; <C1,s2>; <C3,s1>_4; <C5,s1>_6; <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C4,s1>_4 <C2,s1>_2 <C0,s1> <C1,s1>_1 <C3,s1>_3 <C5,s1>_5 <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 0 | <C5,s1>_5, fanIn = 0 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 1 | <C4,s1>_4, fanIn = 0 | <C2,s1>_2, fanIn = 0 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 8 ----------------
node to be examined: <C6,s1>_7
<C6,s1>_7 is NOT an initial node => need to look for parent
<C6,s1>_6 chosen with max fanIn value
origin node chosen: <C6,s1>_6
Update fanIn : fanIn[<C6,s1>_6] <- 0 (due to provide p6_1)
current generation: Generation nr.11: <C6,s1>_7; <C4,s1>_5; <C2,s1>_3; <C1,s2>; <C3,s1>_4; <C5,s1>_6; <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C6,s1>_6 <C4,s1>_4 <C2,s1>_2 <C0,s1> <C1,s1>_1 <C3,s1>_3 <C5,s1>_5 <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 0 | <C5,s1>_5, fanIn = 0 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 1 | <C6,s1>_6, fanIn = 0 | <C4,s1>_4, fanIn = 0 | <C2,s1>_2, fanIn = 0 | <C0,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 9 ----------------
node to be examined: <C8,s1>_9
<C8,s1>_9 is NOT an initial node => need to look for parent
<C8,s1>_8 chosen with max fanIn value
origin node chosen: <C8,s1>_8
Update fanIn : fanIn[<C8,s1>_8] <- 0 (due to provide p8_1)
current generation: Generation nr.11: <C8,s1>_9; <C6,s1>_7; <C4,s1>_5; <C2,s1>_3; <C1,s2>; <C3,s1>_4; <C5,s1>_6; <C7,s1>_8; <C9,s1>_10
next working set, at level nr.10 : { <C8,s1>_8 <C6,s1>_6 <C4,s1>_4 <C2,s1>_2 <C0,s1> <C1,s1>_1 <C3,s1>_3 <C5,s1>_5 <C7,s1>_7 <C9,s1>_9  }
Nodes with fanIn values:
<C1,s1>_1, fanIn = 0 | <C3,s1>_3, fanIn = 0 | <C5,s1>_5, fanIn = 0 | <C7,s1>_7, fanIn = 0 | <C9,s1>_9, fanIn = 0 | <C9,s0>_10, fanIn = 0 | <C8,s0>_10, fanIn = 0 | <C7,s0>_10, fanIn = 0 | <C6,s0>_10, fanIn = 0 | <C5,s0>_10, fanIn = 0 | <C4,s0>_10, fanIn = 0 | <C3,s0>_10, fanIn = 0 | <C2,s0>_10, fanIn = 0 | <C1,s0>_10, fanIn = 0 | <C0,s0>_10, fanIn = 0 | <C8,s1>_8, fanIn = 0 | <C6,s1>_6, fanIn = 0 | <C4,s1>_4, fanIn = 0 | <C2,s1>_2, fanIn = 0 | <C0,s1>, fanIn = 1
Total requires: p9_1 | p7_1 | p5_1 | p3_1 | p1_1 | p2_1 | p4_1 | p6_1 | p8_1
fanIn[<C2,s1>_1] := 1
fanIn[<C4,s1>_3] := 1
fanIn[<C6,s1>_5] := 1
fanIn[<C8,s1>_7] := 1
fanIn[<C0,s0>_9] := 0
fanIn[<C1,s0>_9] := 0
fanIn[<C2,s0>_9] := 0
fanIn[<C3,s0>_9] := 0
fanIn[<C4,s0>_9] := 0
fanIn[<C5,s0>_9] := 0
fanIn[<C6,s0>_9] := 0
fanIn[<C7,s0>_9] := 0
fanIn[<C8,s0>_9] := 0
fanIn[<C9,s0>_9] := 0
fanIn[<C9,s1>_8] := 1
fanIn[<C7,s1>_6] := 1
fanIn[<C5,s1>_4] := 1
fanIn[<C3,s1>_2] := 1
fanIn[<C1,s1>] := 1
Nodes with fanIn values:
<C2,s1>_1, fanIn = 1 | <C4,s1>_3, fanIn = 1 | <C6,s1>_5, fanIn = 1 | <C8,s1>_7, fanIn = 1 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 1 | <C1,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>_8
<C8,s1>_8 is NOT an initial node => need to look for parent
<C8,s1>_7 chosen with max fanIn value
origin node chosen: <C8,s1>_7
Update fanIn : fanIn[<C8,s1>_7] <- 0 (due to provide p8_1)
current generation: Generation nr.10: <C8,s1>_8
next working set, at level nr.9 : { <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 1 | <C4,s1>_3, fanIn = 1 | <C6,s1>_5, fanIn = 1 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 1 | <C1,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s1>_6
<C6,s1>_6 is NOT an initial node => need to look for parent
<C6,s1>_5 chosen with max fanIn value
origin node chosen: <C6,s1>_5
Update fanIn : fanIn[<C6,s1>_5] <- 0 (due to provide p6_1)
current generation: Generation nr.10: <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 1 | <C4,s1>_3, fanIn = 1 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 1 | <C1,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 3 ----------------
node to be examined: <C4,s1>_4
<C4,s1>_4 is NOT an initial node => need to look for parent
<C4,s1>_3 chosen with max fanIn value
origin node chosen: <C4,s1>_3
Update fanIn : fanIn[<C4,s1>_3] <- 0 (due to provide p4_1)
current generation: Generation nr.10: <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 1 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 1 | <C1,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 4 ----------------
node to be examined: <C2,s1>_2
<C2,s1>_2 is NOT an initial node => need to look for parent
<C2,s1>_1 chosen with max fanIn value
origin node chosen: <C2,s1>_1
Update fanIn : fanIn[<C2,s1>_1] <- 0 (due to provide p2_1)
current generation: Generation nr.10: <C2,s1>_2; <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C2,s1>_1 <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 0 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 1 | <C1,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 5 ----------------
node to be examined: <C0,s1>
<C0,s1> is NOT an initial node => need to look for parent
<C0,s0>_9 chosen with max fanIn value
origin node chosen: <C0,s0>_9
<C0,s1> is NOT a copy => must take care of providers
list of chosen providers: <C1,s1> 
current generation: Generation nr.10: <C0,s1>; <C2,s1>_2; <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C1,s1> <C0,s0>_9 <C2,s1>_1 <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 0 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 1 | <C1,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 6 ----------------
node to be examined: <C1,s1>_1
<C1,s1>_1 is NOT an initial node => need to look for parent
<C1,s1> chosen with max fanIn value
origin node chosen: <C1,s1>
Update fanIn : fanIn[<C1,s1>] <- 0 (due to provide p1_1)
current generation: Generation nr.10: <C1,s1>_1; <C0,s1>; <C2,s1>_2; <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C1,s1> <C0,s0>_9 <C2,s1>_1 <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 0 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 1 | <C1,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 7 ----------------
node to be examined: <C3,s1>_3
<C3,s1>_3 is NOT an initial node => need to look for parent
<C3,s1>_2 chosen with max fanIn value
origin node chosen: <C3,s1>_2
Update fanIn : fanIn[<C3,s1>_2] <- 0 (due to provide p3_1)
current generation: Generation nr.10: <C3,s1>_3; <C1,s1>_1; <C0,s1>; <C2,s1>_2; <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C3,s1>_2 <C1,s1> <C0,s0>_9 <C2,s1>_1 <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 0 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 1 | <C3,s1>_2, fanIn = 0 | <C1,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 8 ----------------
node to be examined: <C5,s1>_5
<C5,s1>_5 is NOT an initial node => need to look for parent
<C5,s1>_4 chosen with max fanIn value
origin node chosen: <C5,s1>_4
Update fanIn : fanIn[<C5,s1>_4] <- 0 (due to provide p5_1)
current generation: Generation nr.10: <C5,s1>_5; <C3,s1>_3; <C1,s1>_1; <C0,s1>; <C2,s1>_2; <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C5,s1>_4 <C3,s1>_2 <C1,s1> <C0,s0>_9 <C2,s1>_1 <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 0 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 1 | <C5,s1>_4, fanIn = 0 | <C3,s1>_2, fanIn = 0 | <C1,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 9 ----------------
node to be examined: <C7,s1>_7
<C7,s1>_7 is NOT an initial node => need to look for parent
<C7,s1>_6 chosen with max fanIn value
origin node chosen: <C7,s1>_6
Update fanIn : fanIn[<C7,s1>_6] <- 0 (due to provide p7_1)
current generation: Generation nr.10: <C7,s1>_7; <C5,s1>_5; <C3,s1>_3; <C1,s1>_1; <C0,s1>; <C2,s1>_2; <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C7,s1>_6 <C5,s1>_4 <C3,s1>_2 <C1,s1> <C0,s0>_9 <C2,s1>_1 <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 0 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 1 | <C7,s1>_6, fanIn = 0 | <C5,s1>_4, fanIn = 0 | <C3,s1>_2, fanIn = 0 | <C1,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 10 ----------------
node to be examined: <C9,s1>_9
<C9,s1>_9 is NOT an initial node => need to look for parent
<C9,s1>_8 chosen with max fanIn value
origin node chosen: <C9,s1>_8
Update fanIn : fanIn[<C9,s1>_8] <- 0 (due to provide p9_1)
current generation: Generation nr.10: <C9,s1>_9; <C7,s1>_7; <C5,s1>_5; <C3,s1>_3; <C1,s1>_1; <C0,s1>; <C2,s1>_2; <C4,s1>_4; <C6,s1>_6; <C8,s1>_8
next working set, at level nr.9 : { <C9,s1>_8 <C7,s1>_6 <C5,s1>_4 <C3,s1>_2 <C1,s1> <C0,s0>_9 <C2,s1>_1 <C4,s1>_3 <C6,s1>_5 <C8,s1>_7  }
Nodes with fanIn values:
<C2,s1>_1, fanIn = 0 | <C4,s1>_3, fanIn = 0 | <C6,s1>_5, fanIn = 0 | <C8,s1>_7, fanIn = 0 | <C0,s0>_9, fanIn = 0 | <C1,s0>_9, fanIn = 0 | <C2,s0>_9, fanIn = 0 | <C3,s0>_9, fanIn = 0 | <C4,s0>_9, fanIn = 0 | <C5,s0>_9, fanIn = 0 | <C6,s0>_9, fanIn = 0 | <C7,s0>_9, fanIn = 0 | <C8,s0>_9, fanIn = 0 | <C9,s0>_9, fanIn = 0 | <C9,s1>_8, fanIn = 0 | <C7,s1>_6, fanIn = 0 | <C5,s1>_4, fanIn = 0 | <C3,s1>_2, fanIn = 0 | <C1,s1>, fanIn = 0
Total requires: p8_1 | p6_1 | p4_1 | p2_1 | p3_1 | p5_1 | p7_1 | p9_1
fanIn[<C3,s1>_1] := 1
fanIn[<C5,s1>_3] := 1
fanIn[<C7,s1>_5] := 1
fanIn[<C9,s1>_7] := 1
fanIn[<C9,s0>_8] := 0
fanIn[<C8,s0>_8] := 0
fanIn[<C7,s0>_8] := 0
fanIn[<C6,s0>_8] := 0
fanIn[<C5,s0>_8] := 0
fanIn[<C4,s0>_8] := 0
fanIn[<C3,s0>_8] := 0
fanIn[<C2,s0>_8] := 0
fanIn[<C1,s0>_8] := 0
fanIn[<C0,s0>_8] := 0
fanIn[<C8,s1>_6] := 1
fanIn[<C6,s1>_4] := 1
fanIn[<C4,s1>_2] := 1
fanIn[<C2,s1>] := 1
Nodes with fanIn values:
<C3,s1>_1, fanIn = 1 | <C5,s1>_3, fanIn = 1 | <C7,s1>_5, fanIn = 1 | <C9,s1>_7, fanIn = 1 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_8
<C9,s1>_8 is NOT an initial node => need to look for parent
<C9,s1>_7 chosen with max fanIn value
origin node chosen: <C9,s1>_7
Update fanIn : fanIn[<C9,s1>_7] <- 0 (due to provide p9_1)
current generation: Generation nr.9: <C9,s1>_8
next working set, at level nr.8 : { <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 1 | <C5,s1>_3, fanIn = 1 | <C7,s1>_5, fanIn = 1 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s1>_6
<C7,s1>_6 is NOT an initial node => need to look for parent
<C7,s1>_5 chosen with max fanIn value
origin node chosen: <C7,s1>_5
Update fanIn : fanIn[<C7,s1>_5] <- 0 (due to provide p7_1)
current generation: Generation nr.9: <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 1 | <C5,s1>_3, fanIn = 1 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s1>_4
<C5,s1>_4 is NOT an initial node => need to look for parent
<C5,s1>_3 chosen with max fanIn value
origin node chosen: <C5,s1>_3
Update fanIn : fanIn[<C5,s1>_3] <- 0 (due to provide p5_1)
current generation: Generation nr.9: <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 1 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 4 ----------------
node to be examined: <C3,s1>_2
<C3,s1>_2 is NOT an initial node => need to look for parent
<C3,s1>_1 chosen with max fanIn value
origin node chosen: <C3,s1>_1
Update fanIn : fanIn[<C3,s1>_1] <- 0 (due to provide p3_1)
current generation: Generation nr.9: <C3,s1>_2; <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C3,s1>_1 <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 0 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 5 ----------------
node to be examined: <C1,s1>
<C1,s1> is NOT an initial node => need to look for parent
<C1,s0>_8 chosen with max fanIn value
origin node chosen: <C1,s0>_8
<C1,s1> is NOT a copy => must take care of providers
list of chosen providers: <C2,s1> 
current generation: Generation nr.9: <C1,s1>; <C3,s1>_2; <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C2,s1> <C1,s0>_8 <C3,s1>_1 <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 0 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 6 ----------------
node to be examined: <C0,s0>_9
<C0,s0>_9 is an initial node => no need to look for parent and providers
current generation: Generation nr.9: <C0,s0>_9; <C1,s1>; <C3,s1>_2; <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C0,s0> <C2,s1> <C1,s0>_8 <C3,s1>_1 <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 0 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 7 ----------------
node to be examined: <C2,s1>_1
<C2,s1>_1 is NOT an initial node => need to look for parent
<C2,s1> chosen with max fanIn value
origin node chosen: <C2,s1>
Update fanIn : fanIn[<C2,s1>] <- 0 (due to provide p2_1)
current generation: Generation nr.9: <C2,s1>_1; <C0,s0>_9; <C1,s1>; <C3,s1>_2; <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C2,s1> <C0,s0> <C1,s0>_8 <C3,s1>_1 <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 0 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 1 | <C2,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 8 ----------------
node to be examined: <C4,s1>_3
<C4,s1>_3 is NOT an initial node => need to look for parent
<C4,s1>_2 chosen with max fanIn value
origin node chosen: <C4,s1>_2
Update fanIn : fanIn[<C4,s1>_2] <- 0 (due to provide p4_1)
current generation: Generation nr.9: <C4,s1>_3; <C2,s1>_1; <C0,s0>_9; <C1,s1>; <C3,s1>_2; <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C4,s1>_2 <C2,s1> <C0,s0> <C1,s0>_8 <C3,s1>_1 <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 0 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 1 | <C4,s1>_2, fanIn = 0 | <C2,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 9 ----------------
node to be examined: <C6,s1>_5
<C6,s1>_5 is NOT an initial node => need to look for parent
<C6,s1>_4 chosen with max fanIn value
origin node chosen: <C6,s1>_4
Update fanIn : fanIn[<C6,s1>_4] <- 0 (due to provide p6_1)
current generation: Generation nr.9: <C6,s1>_5; <C4,s1>_3; <C2,s1>_1; <C0,s0>_9; <C1,s1>; <C3,s1>_2; <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C6,s1>_4 <C4,s1>_2 <C2,s1> <C0,s0> <C1,s0>_8 <C3,s1>_1 <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 0 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 1 | <C6,s1>_4, fanIn = 0 | <C4,s1>_2, fanIn = 0 | <C2,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 10 ----------------
node to be examined: <C8,s1>_7
<C8,s1>_7 is NOT an initial node => need to look for parent
<C8,s1>_6 chosen with max fanIn value
origin node chosen: <C8,s1>_6
Update fanIn : fanIn[<C8,s1>_6] <- 0 (due to provide p8_1)
current generation: Generation nr.9: <C8,s1>_7; <C6,s1>_5; <C4,s1>_3; <C2,s1>_1; <C0,s0>_9; <C1,s1>; <C3,s1>_2; <C5,s1>_4; <C7,s1>_6; <C9,s1>_8
next working set, at level nr.8 : { <C8,s1>_6 <C6,s1>_4 <C4,s1>_2 <C2,s1> <C0,s0> <C1,s0>_8 <C3,s1>_1 <C5,s1>_3 <C7,s1>_5 <C9,s1>_7  }
Nodes with fanIn values:
<C3,s1>_1, fanIn = 0 | <C5,s1>_3, fanIn = 0 | <C7,s1>_5, fanIn = 0 | <C9,s1>_7, fanIn = 0 | <C9,s0>_8, fanIn = 0 | <C8,s0>_8, fanIn = 0 | <C7,s0>_8, fanIn = 0 | <C6,s0>_8, fanIn = 0 | <C5,s0>_8, fanIn = 0 | <C4,s0>_8, fanIn = 0 | <C3,s0>_8, fanIn = 0 | <C2,s0>_8, fanIn = 0 | <C1,s0>_8, fanIn = 0 | <C0,s0>_8, fanIn = 0 | <C8,s1>_6, fanIn = 0 | <C6,s1>_4, fanIn = 0 | <C4,s1>_2, fanIn = 0 | <C2,s1>, fanIn = 0
Total requires: p9_1 | p7_1 | p5_1 | p3_1 | p4_1 | p6_1 | p8_1
fanIn[<C4,s1>_1] := 1
fanIn[<C6,s1>_3] := 1
fanIn[<C8,s1>_5] := 1
fanIn[<C0,s0>_7] := 0
fanIn[<C1,s0>_7] := 0
fanIn[<C2,s0>_7] := 0
fanIn[<C3,s0>_7] := 0
fanIn[<C4,s0>_7] := 0
fanIn[<C5,s0>_7] := 0
fanIn[<C6,s0>_7] := 0
fanIn[<C7,s0>_7] := 0
fanIn[<C8,s0>_7] := 0
fanIn[<C9,s0>_7] := 0
fanIn[<C9,s1>_6] := 1
fanIn[<C7,s1>_4] := 1
fanIn[<C5,s1>_2] := 1
fanIn[<C3,s1>] := 1
Nodes with fanIn values:
<C4,s1>_1, fanIn = 1 | <C6,s1>_3, fanIn = 1 | <C8,s1>_5, fanIn = 1 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>_6
<C8,s1>_6 is NOT an initial node => need to look for parent
<C8,s1>_5 chosen with max fanIn value
origin node chosen: <C8,s1>_5
Update fanIn : fanIn[<C8,s1>_5] <- 0 (due to provide p8_1)
current generation: Generation nr.8: <C8,s1>_6
next working set, at level nr.7 : { <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 1 | <C6,s1>_3, fanIn = 1 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s1>_4
<C6,s1>_4 is NOT an initial node => need to look for parent
<C6,s1>_3 chosen with max fanIn value
origin node chosen: <C6,s1>_3
Update fanIn : fanIn[<C6,s1>_3] <- 0 (due to provide p6_1)
current generation: Generation nr.8: <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 1 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 3 ----------------
node to be examined: <C4,s1>_2
<C4,s1>_2 is NOT an initial node => need to look for parent
<C4,s1>_1 chosen with max fanIn value
origin node chosen: <C4,s1>_1
Update fanIn : fanIn[<C4,s1>_1] <- 0 (due to provide p4_1)
current generation: Generation nr.8: <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 4 ----------------
node to be examined: <C2,s1>
<C2,s1> is NOT an initial node => need to look for parent
<C2,s0>_7 chosen with max fanIn value
origin node chosen: <C2,s0>_7
<C2,s1> is NOT a copy => must take care of providers
list of chosen providers: <C3,s1> 
current generation: Generation nr.8: <C2,s1>; <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C3,s1> <C2,s0>_7 <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 5 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.8: <C0,s0>; <C2,s1>; <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C0,s0> <C3,s1> <C2,s0>_7 <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 6 ----------------
node to be examined: <C1,s0>_8
<C1,s0>_8 is an initial node => no need to look for parent and providers
current generation: Generation nr.8: <C1,s0>_8; <C0,s0>; <C2,s1>; <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C1,s0> <C0,s0> <C3,s1> <C2,s0>_7 <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 7 ----------------
node to be examined: <C3,s1>_1
<C3,s1>_1 is NOT an initial node => need to look for parent
<C3,s1> chosen with max fanIn value
origin node chosen: <C3,s1>
Update fanIn : fanIn[<C3,s1>] <- 0 (due to provide p3_1)
current generation: Generation nr.8: <C3,s1>_1; <C1,s0>_8; <C0,s0>; <C2,s1>; <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C3,s1> <C1,s0> <C0,s0> <C2,s0>_7 <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 1 | <C3,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 8 ----------------
node to be examined: <C5,s1>_3
<C5,s1>_3 is NOT an initial node => need to look for parent
<C5,s1>_2 chosen with max fanIn value
origin node chosen: <C5,s1>_2
Update fanIn : fanIn[<C5,s1>_2] <- 0 (due to provide p5_1)
current generation: Generation nr.8: <C5,s1>_3; <C3,s1>_1; <C1,s0>_8; <C0,s0>; <C2,s1>; <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C5,s1>_2 <C3,s1> <C1,s0> <C0,s0> <C2,s0>_7 <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 1 | <C5,s1>_2, fanIn = 0 | <C3,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 9 ----------------
node to be examined: <C7,s1>_5
<C7,s1>_5 is NOT an initial node => need to look for parent
<C7,s1>_4 chosen with max fanIn value
origin node chosen: <C7,s1>_4
Update fanIn : fanIn[<C7,s1>_4] <- 0 (due to provide p7_1)
current generation: Generation nr.8: <C7,s1>_5; <C5,s1>_3; <C3,s1>_1; <C1,s0>_8; <C0,s0>; <C2,s1>; <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C7,s1>_4 <C5,s1>_2 <C3,s1> <C1,s0> <C0,s0> <C2,s0>_7 <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 1 | <C7,s1>_4, fanIn = 0 | <C5,s1>_2, fanIn = 0 | <C3,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 10 ----------------
node to be examined: <C9,s1>_7
<C9,s1>_7 is NOT an initial node => need to look for parent
<C9,s1>_6 chosen with max fanIn value
origin node chosen: <C9,s1>_6
Update fanIn : fanIn[<C9,s1>_6] <- 0 (due to provide p9_1)
current generation: Generation nr.8: <C9,s1>_7; <C7,s1>_5; <C5,s1>_3; <C3,s1>_1; <C1,s0>_8; <C0,s0>; <C2,s1>; <C4,s1>_2; <C6,s1>_4; <C8,s1>_6
next working set, at level nr.7 : { <C9,s1>_6 <C7,s1>_4 <C5,s1>_2 <C3,s1> <C1,s0> <C0,s0> <C2,s0>_7 <C4,s1>_1 <C6,s1>_3 <C8,s1>_5  }
Nodes with fanIn values:
<C4,s1>_1, fanIn = 0 | <C6,s1>_3, fanIn = 0 | <C8,s1>_5, fanIn = 0 | <C0,s0>_7, fanIn = 0 | <C1,s0>_7, fanIn = 0 | <C2,s0>_7, fanIn = 0 | <C3,s0>_7, fanIn = 0 | <C4,s0>_7, fanIn = 0 | <C5,s0>_7, fanIn = 0 | <C6,s0>_7, fanIn = 0 | <C7,s0>_7, fanIn = 0 | <C8,s0>_7, fanIn = 0 | <C9,s0>_7, fanIn = 0 | <C9,s1>_6, fanIn = 0 | <C7,s1>_4, fanIn = 0 | <C5,s1>_2, fanIn = 0 | <C3,s1>, fanIn = 0
Total requires: p8_1 | p6_1 | p4_1 | p5_1 | p7_1 | p9_1
fanIn[<C5,s1>_1] := 1
fanIn[<C7,s1>_3] := 1
fanIn[<C9,s1>_5] := 1
fanIn[<C9,s0>_6] := 0
fanIn[<C8,s0>_6] := 0
fanIn[<C7,s0>_6] := 0
fanIn[<C6,s0>_6] := 0
fanIn[<C5,s0>_6] := 0
fanIn[<C4,s0>_6] := 0
fanIn[<C3,s0>_6] := 0
fanIn[<C2,s0>_6] := 0
fanIn[<C1,s0>_6] := 0
fanIn[<C0,s0>_6] := 0
fanIn[<C8,s1>_4] := 1
fanIn[<C6,s1>_2] := 1
fanIn[<C4,s1>] := 1
Nodes with fanIn values:
<C5,s1>_1, fanIn = 1 | <C7,s1>_3, fanIn = 1 | <C9,s1>_5, fanIn = 1 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_6
<C9,s1>_6 is NOT an initial node => need to look for parent
<C9,s1>_5 chosen with max fanIn value
origin node chosen: <C9,s1>_5
Update fanIn : fanIn[<C9,s1>_5] <- 0 (due to provide p9_1)
current generation: Generation nr.7: <C9,s1>_6
next working set, at level nr.6 : { <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 1 | <C7,s1>_3, fanIn = 1 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s1>_4
<C7,s1>_4 is NOT an initial node => need to look for parent
<C7,s1>_3 chosen with max fanIn value
origin node chosen: <C7,s1>_3
Update fanIn : fanIn[<C7,s1>_3] <- 0 (due to provide p7_1)
current generation: Generation nr.7: <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 1 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s1>_2
<C5,s1>_2 is NOT an initial node => need to look for parent
<C5,s1>_1 chosen with max fanIn value
origin node chosen: <C5,s1>_1
Update fanIn : fanIn[<C5,s1>_1] <- 0 (due to provide p5_1)
current generation: Generation nr.7: <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 4 ----------------
node to be examined: <C3,s1>
<C3,s1> is NOT an initial node => need to look for parent
<C3,s0>_6 chosen with max fanIn value
origin node chosen: <C3,s0>_6
<C3,s1> is NOT a copy => must take care of providers
list of chosen providers: <C4,s1> 
current generation: Generation nr.7: <C3,s1>; <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C4,s1> <C3,s0>_6 <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 5 ----------------
node to be examined: <C1,s0>
<C1,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.7: <C1,s0>; <C3,s1>; <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C1,s0> <C4,s1> <C3,s0>_6 <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 6 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.7: <C0,s0>; <C1,s0>; <C3,s1>; <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C0,s0> <C1,s0> <C4,s1> <C3,s0>_6 <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 7 ----------------
node to be examined: <C2,s0>_7
<C2,s0>_7 is an initial node => no need to look for parent and providers
current generation: Generation nr.7: <C2,s0>_7; <C0,s0>; <C1,s0>; <C3,s1>; <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C2,s0> <C0,s0> <C1,s0> <C4,s1> <C3,s0>_6 <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 8 ----------------
node to be examined: <C4,s1>_1
<C4,s1>_1 is NOT an initial node => need to look for parent
<C4,s1> chosen with max fanIn value
origin node chosen: <C4,s1>
Update fanIn : fanIn[<C4,s1>] <- 0 (due to provide p4_1)
current generation: Generation nr.7: <C4,s1>_1; <C2,s0>_7; <C0,s0>; <C1,s0>; <C3,s1>; <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C4,s1> <C2,s0> <C0,s0> <C1,s0> <C3,s0>_6 <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 1 | <C4,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 9 ----------------
node to be examined: <C6,s1>_3
<C6,s1>_3 is NOT an initial node => need to look for parent
<C6,s1>_2 chosen with max fanIn value
origin node chosen: <C6,s1>_2
Update fanIn : fanIn[<C6,s1>_2] <- 0 (due to provide p6_1)
current generation: Generation nr.7: <C6,s1>_3; <C4,s1>_1; <C2,s0>_7; <C0,s0>; <C1,s0>; <C3,s1>; <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C6,s1>_2 <C4,s1> <C2,s0> <C0,s0> <C1,s0> <C3,s0>_6 <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 1 | <C6,s1>_2, fanIn = 0 | <C4,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 10 ----------------
node to be examined: <C8,s1>_5
<C8,s1>_5 is NOT an initial node => need to look for parent
<C8,s1>_4 chosen with max fanIn value
origin node chosen: <C8,s1>_4
Update fanIn : fanIn[<C8,s1>_4] <- 0 (due to provide p8_1)
current generation: Generation nr.7: <C8,s1>_5; <C6,s1>_3; <C4,s1>_1; <C2,s0>_7; <C0,s0>; <C1,s0>; <C3,s1>; <C5,s1>_2; <C7,s1>_4; <C9,s1>_6
next working set, at level nr.6 : { <C8,s1>_4 <C6,s1>_2 <C4,s1> <C2,s0> <C0,s0> <C1,s0> <C3,s0>_6 <C5,s1>_1 <C7,s1>_3 <C9,s1>_5  }
Nodes with fanIn values:
<C5,s1>_1, fanIn = 0 | <C7,s1>_3, fanIn = 0 | <C9,s1>_5, fanIn = 0 | <C9,s0>_6, fanIn = 0 | <C8,s0>_6, fanIn = 0 | <C7,s0>_6, fanIn = 0 | <C6,s0>_6, fanIn = 0 | <C5,s0>_6, fanIn = 0 | <C4,s0>_6, fanIn = 0 | <C3,s0>_6, fanIn = 0 | <C2,s0>_6, fanIn = 0 | <C1,s0>_6, fanIn = 0 | <C0,s0>_6, fanIn = 0 | <C8,s1>_4, fanIn = 0 | <C6,s1>_2, fanIn = 0 | <C4,s1>, fanIn = 0
Total requires: p9_1 | p7_1 | p5_1 | p6_1 | p8_1
fanIn[<C6,s1>_1] := 1
fanIn[<C8,s1>_3] := 1
fanIn[<C0,s0>_5] := 0
fanIn[<C1,s0>_5] := 0
fanIn[<C2,s0>_5] := 0
fanIn[<C3,s0>_5] := 0
fanIn[<C4,s0>_5] := 0
fanIn[<C5,s0>_5] := 0
fanIn[<C6,s0>_5] := 0
fanIn[<C7,s0>_5] := 0
fanIn[<C8,s0>_5] := 0
fanIn[<C9,s0>_5] := 0
fanIn[<C9,s1>_4] := 1
fanIn[<C7,s1>_2] := 1
fanIn[<C5,s1>] := 1
Nodes with fanIn values:
<C6,s1>_1, fanIn = 1 | <C8,s1>_3, fanIn = 1 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>_4
<C8,s1>_4 is NOT an initial node => need to look for parent
<C8,s1>_3 chosen with max fanIn value
origin node chosen: <C8,s1>_3
Update fanIn : fanIn[<C8,s1>_3] <- 0 (due to provide p8_1)
current generation: Generation nr.6: <C8,s1>_4
next working set, at level nr.5 : { <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 1 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s1>_2
<C6,s1>_2 is NOT an initial node => need to look for parent
<C6,s1>_1 chosen with max fanIn value
origin node chosen: <C6,s1>_1
Update fanIn : fanIn[<C6,s1>_1] <- 0 (due to provide p6_1)
current generation: Generation nr.6: <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 3 ----------------
node to be examined: <C4,s1>
<C4,s1> is NOT an initial node => need to look for parent
<C4,s0>_5 chosen with max fanIn value
origin node chosen: <C4,s0>_5
<C4,s1> is NOT a copy => must take care of providers
list of chosen providers: <C5,s1> 
current generation: Generation nr.6: <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C5,s1> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 4 ----------------
node to be examined: <C2,s0>
<C2,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.6: <C2,s0>; <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C2,s0> <C5,s1> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 5 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.6: <C0,s0>; <C2,s0>; <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C0,s0> <C2,s0> <C5,s1> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 6 ----------------
node to be examined: <C1,s0>
<C1,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.6: <C1,s0>; <C0,s0>; <C2,s0>; <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C1,s0> <C0,s0> <C2,s0> <C5,s1> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 7 ----------------
node to be examined: <C3,s0>_6
<C3,s0>_6 is an initial node => no need to look for parent and providers
current generation: Generation nr.6: <C3,s0>_6; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C5,s1> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 8 ----------------
node to be examined: <C5,s1>_1
<C5,s1>_1 is NOT an initial node => need to look for parent
<C5,s1> chosen with max fanIn value
origin node chosen: <C5,s1>
Update fanIn : fanIn[<C5,s1>] <- 0 (due to provide p5_1)
current generation: Generation nr.6: <C5,s1>_1; <C3,s0>_6; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C5,s1> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 1 | <C5,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 9 ----------------
node to be examined: <C7,s1>_3
<C7,s1>_3 is NOT an initial node => need to look for parent
<C7,s1>_2 chosen with max fanIn value
origin node chosen: <C7,s1>_2
Update fanIn : fanIn[<C7,s1>_2] <- 0 (due to provide p7_1)
current generation: Generation nr.6: <C7,s1>_3; <C5,s1>_1; <C3,s0>_6; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C7,s1>_2 <C5,s1> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 1 | <C7,s1>_2, fanIn = 0 | <C5,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 10 ----------------
node to be examined: <C9,s1>_5
<C9,s1>_5 is NOT an initial node => need to look for parent
<C9,s1>_4 chosen with max fanIn value
origin node chosen: <C9,s1>_4
Update fanIn : fanIn[<C9,s1>_4] <- 0 (due to provide p9_1)
current generation: Generation nr.6: <C9,s1>_5; <C7,s1>_3; <C5,s1>_1; <C3,s0>_6; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s1>; <C6,s1>_2; <C8,s1>_4
next working set, at level nr.5 : { <C9,s1>_4 <C7,s1>_2 <C5,s1> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0>_5 <C6,s1>_1 <C8,s1>_3  }
Nodes with fanIn values:
<C6,s1>_1, fanIn = 0 | <C8,s1>_3, fanIn = 0 | <C0,s0>_5, fanIn = 0 | <C1,s0>_5, fanIn = 0 | <C2,s0>_5, fanIn = 0 | <C3,s0>_5, fanIn = 0 | <C4,s0>_5, fanIn = 0 | <C5,s0>_5, fanIn = 0 | <C6,s0>_5, fanIn = 0 | <C7,s0>_5, fanIn = 0 | <C8,s0>_5, fanIn = 0 | <C9,s0>_5, fanIn = 0 | <C9,s1>_4, fanIn = 0 | <C7,s1>_2, fanIn = 0 | <C5,s1>, fanIn = 0
Total requires: p8_1 | p6_1 | p7_1 | p9_1
fanIn[<C7,s1>_1] := 1
fanIn[<C9,s1>_3] := 1
fanIn[<C9,s0>_4] := 0
fanIn[<C8,s0>_4] := 0
fanIn[<C7,s0>_4] := 0
fanIn[<C6,s0>_4] := 0
fanIn[<C5,s0>_4] := 0
fanIn[<C4,s0>_4] := 0
fanIn[<C3,s0>_4] := 0
fanIn[<C2,s0>_4] := 0
fanIn[<C1,s0>_4] := 0
fanIn[<C0,s0>_4] := 0
fanIn[<C8,s1>_2] := 1
fanIn[<C6,s1>] := 1
Nodes with fanIn values:
<C7,s1>_1, fanIn = 1 | <C9,s1>_3, fanIn = 1 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_4
<C9,s1>_4 is NOT an initial node => need to look for parent
<C9,s1>_3 chosen with max fanIn value
origin node chosen: <C9,s1>_3
Update fanIn : fanIn[<C9,s1>_3] <- 0 (due to provide p9_1)
current generation: Generation nr.5: <C9,s1>_4
next working set, at level nr.4 : { <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 1 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s1>_2
<C7,s1>_2 is NOT an initial node => need to look for parent
<C7,s1>_1 chosen with max fanIn value
origin node chosen: <C7,s1>_1
Update fanIn : fanIn[<C7,s1>_1] <- 0 (due to provide p7_1)
current generation: Generation nr.5: <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s1>
<C5,s1> is NOT an initial node => need to look for parent
<C5,s0>_4 chosen with max fanIn value
origin node chosen: <C5,s0>_4
<C5,s1> is NOT a copy => must take care of providers
list of chosen providers: <C6,s1> 
current generation: Generation nr.5: <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C6,s1> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 4 ----------------
node to be examined: <C3,s0>
<C3,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.5: <C3,s0>; <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C3,s0> <C6,s1> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 5 ----------------
node to be examined: <C1,s0>
<C1,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.5: <C1,s0>; <C3,s0>; <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C1,s0> <C3,s0> <C6,s1> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 6 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.5: <C0,s0>; <C1,s0>; <C3,s0>; <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C0,s0> <C1,s0> <C3,s0> <C6,s1> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 7 ----------------
node to be examined: <C2,s0>
<C2,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.5: <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C6,s1> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 8 ----------------
node to be examined: <C4,s0>_5
<C4,s0>_5 is an initial node => no need to look for parent and providers
current generation: Generation nr.5: <C4,s0>_5; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C6,s1> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 9 ----------------
node to be examined: <C6,s1>_1
<C6,s1>_1 is NOT an initial node => need to look for parent
<C6,s1> chosen with max fanIn value
origin node chosen: <C6,s1>
Update fanIn : fanIn[<C6,s1>] <- 0 (due to provide p6_1)
current generation: Generation nr.5: <C6,s1>_1; <C4,s0>_5; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C6,s1> <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 1 | <C6,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 10 ----------------
node to be examined: <C8,s1>_3
<C8,s1>_3 is NOT an initial node => need to look for parent
<C8,s1>_2 chosen with max fanIn value
origin node chosen: <C8,s1>_2
Update fanIn : fanIn[<C8,s1>_2] <- 0 (due to provide p8_1)
current generation: Generation nr.5: <C8,s1>_3; <C6,s1>_1; <C4,s0>_5; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s1>; <C7,s1>_2; <C9,s1>_4
next working set, at level nr.4 : { <C8,s1>_2 <C6,s1> <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0>_4 <C7,s1>_1 <C9,s1>_3  }
Nodes with fanIn values:
<C7,s1>_1, fanIn = 0 | <C9,s1>_3, fanIn = 0 | <C9,s0>_4, fanIn = 0 | <C8,s0>_4, fanIn = 0 | <C7,s0>_4, fanIn = 0 | <C6,s0>_4, fanIn = 0 | <C5,s0>_4, fanIn = 0 | <C4,s0>_4, fanIn = 0 | <C3,s0>_4, fanIn = 0 | <C2,s0>_4, fanIn = 0 | <C1,s0>_4, fanIn = 0 | <C0,s0>_4, fanIn = 0 | <C8,s1>_2, fanIn = 0 | <C6,s1>, fanIn = 0
Total requires: p9_1 | p7_1 | p8_1
fanIn[<C8,s1>_1] := 1
fanIn[<C0,s0>_3] := 0
fanIn[<C1,s0>_3] := 0
fanIn[<C2,s0>_3] := 0
fanIn[<C3,s0>_3] := 0
fanIn[<C4,s0>_3] := 0
fanIn[<C5,s0>_3] := 0
fanIn[<C6,s0>_3] := 0
fanIn[<C7,s0>_3] := 0
fanIn[<C8,s0>_3] := 0
fanIn[<C9,s0>_3] := 0
fanIn[<C9,s1>_2] := 1
fanIn[<C7,s1>] := 1
Nodes with fanIn values:
<C8,s1>_1, fanIn = 1 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>_2
<C8,s1>_2 is NOT an initial node => need to look for parent
<C8,s1>_1 chosen with max fanIn value
origin node chosen: <C8,s1>_1
Update fanIn : fanIn[<C8,s1>_1] <- 0 (due to provide p8_1)
current generation: Generation nr.4: <C8,s1>_2
next working set, at level nr.3 : { <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s1>
<C6,s1> is NOT an initial node => need to look for parent
<C6,s0>_3 chosen with max fanIn value
origin node chosen: <C6,s0>_3
<C6,s1> is NOT a copy => must take care of providers
list of chosen providers: <C7,s1> 
current generation: Generation nr.4: <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C7,s1> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 3 ----------------
node to be examined: <C4,s0>
<C4,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.4: <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C4,s0> <C7,s1> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 4 ----------------
node to be examined: <C2,s0>
<C2,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.4: <C2,s0>; <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C2,s0> <C4,s0> <C7,s1> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 5 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.4: <C0,s0>; <C2,s0>; <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C0,s0> <C2,s0> <C4,s0> <C7,s1> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 6 ----------------
node to be examined: <C1,s0>
<C1,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.4: <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C7,s1> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 7 ----------------
node to be examined: <C3,s0>
<C3,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.4: <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C7,s1> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 8 ----------------
node to be examined: <C5,s0>_4
<C5,s0>_4 is an initial node => no need to look for parent and providers
current generation: Generation nr.4: <C5,s0>_4; <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C5,s0> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C7,s1> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 9 ----------------
node to be examined: <C7,s1>_1
<C7,s1>_1 is NOT an initial node => need to look for parent
<C7,s1> chosen with max fanIn value
origin node chosen: <C7,s1>
Update fanIn : fanIn[<C7,s1>] <- 0 (due to provide p7_1)
current generation: Generation nr.4: <C7,s1>_1; <C5,s0>_4; <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C7,s1> <C5,s0> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 1 | <C7,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 10 ----------------
node to be examined: <C9,s1>_3
<C9,s1>_3 is NOT an initial node => need to look for parent
<C9,s1>_2 chosen with max fanIn value
origin node chosen: <C9,s1>_2
Update fanIn : fanIn[<C9,s1>_2] <- 0 (due to provide p9_1)
current generation: Generation nr.4: <C9,s1>_3; <C7,s1>_1; <C5,s0>_4; <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s1>; <C8,s1>_2
next working set, at level nr.3 : { <C9,s1>_2 <C7,s1> <C5,s0> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C6,s0>_3 <C8,s1>_1  }
Nodes with fanIn values:
<C8,s1>_1, fanIn = 0 | <C0,s0>_3, fanIn = 0 | <C1,s0>_3, fanIn = 0 | <C2,s0>_3, fanIn = 0 | <C3,s0>_3, fanIn = 0 | <C4,s0>_3, fanIn = 0 | <C5,s0>_3, fanIn = 0 | <C6,s0>_3, fanIn = 0 | <C7,s0>_3, fanIn = 0 | <C8,s0>_3, fanIn = 0 | <C9,s0>_3, fanIn = 0 | <C9,s1>_2, fanIn = 0 | <C7,s1>, fanIn = 0
Total requires: p8_1 | p9_1
fanIn[<C9,s1>_1] := 1
fanIn[<C9,s0>_2] := 0
fanIn[<C8,s0>_2] := 0
fanIn[<C7,s0>_2] := 0
fanIn[<C6,s0>_2] := 0
fanIn[<C5,s0>_2] := 0
fanIn[<C4,s0>_2] := 0
fanIn[<C3,s0>_2] := 0
fanIn[<C2,s0>_2] := 0
fanIn[<C1,s0>_2] := 0
fanIn[<C0,s0>_2] := 0
fanIn[<C8,s1>] := 1
Nodes with fanIn values:
<C9,s1>_1, fanIn = 1 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>_2
<C9,s1>_2 is NOT an initial node => need to look for parent
<C9,s1>_1 chosen with max fanIn value
origin node chosen: <C9,s1>_1
Update fanIn : fanIn[<C9,s1>_1] <- 0 (due to provide p9_1)
current generation: Generation nr.3: <C9,s1>_2
next working set, at level nr.2 : { <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s1>
<C7,s1> is NOT an initial node => need to look for parent
<C7,s0>_2 chosen with max fanIn value
origin node chosen: <C7,s0>_2
<C7,s1> is NOT a copy => must take care of providers
list of chosen providers: <C8,s1> 
current generation: Generation nr.3: <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s0>
<C5,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.3: <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C5,s0> <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 4 ----------------
node to be examined: <C3,s0>
<C3,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.3: <C3,s0>; <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C3,s0> <C5,s0> <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 5 ----------------
node to be examined: <C1,s0>
<C1,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.3: <C1,s0>; <C3,s0>; <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C1,s0> <C3,s0> <C5,s0> <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 6 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.3: <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 7 ----------------
node to be examined: <C2,s0>
<C2,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.3: <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 8 ----------------
node to be examined: <C4,s0>
<C4,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.3: <C4,s0>; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 9 ----------------
node to be examined: <C6,s0>_3
<C6,s0>_3 is an initial node => no need to look for parent and providers
current generation: Generation nr.3: <C6,s0>_3; <C4,s0>; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C6,s0> <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C8,s1> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 10 ----------------
node to be examined: <C8,s1>_1
<C8,s1>_1 is NOT an initial node => need to look for parent
<C8,s1> chosen with max fanIn value
origin node chosen: <C8,s1>
Update fanIn : fanIn[<C8,s1>] <- 0 (due to provide p8_1)
current generation: Generation nr.3: <C8,s1>_1; <C6,s0>_3; <C4,s0>; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s1>; <C9,s1>_2
next working set, at level nr.2 : { <C8,s1> <C6,s0> <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C7,s0>_2 <C9,s1>_1  }
Nodes with fanIn values:
<C9,s1>_1, fanIn = 0 | <C9,s0>_2, fanIn = 0 | <C8,s0>_2, fanIn = 0 | <C7,s0>_2, fanIn = 0 | <C6,s0>_2, fanIn = 0 | <C5,s0>_2, fanIn = 0 | <C4,s0>_2, fanIn = 0 | <C3,s0>_2, fanIn = 0 | <C2,s0>_2, fanIn = 0 | <C1,s0>_2, fanIn = 0 | <C0,s0>_2, fanIn = 0 | <C8,s1>, fanIn = 0
Total requires: p9_1
fanIn[<C0,s0>_1] := 0
fanIn[<C1,s0>_1] := 0
fanIn[<C2,s0>_1] := 0
fanIn[<C3,s0>_1] := 0
fanIn[<C4,s0>_1] := 0
fanIn[<C5,s0>_1] := 0
fanIn[<C6,s0>_1] := 0
fanIn[<C7,s0>_1] := 0
fanIn[<C8,s0>_1] := 0
fanIn[<C9,s0>_1] := 0
fanIn[<C9,s1>] := 1
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 1 ----------------
node to be examined: <C8,s1>
<C8,s1> is NOT an initial node => need to look for parent
<C8,s0>_1 chosen with max fanIn value
origin node chosen: <C8,s0>_1
<C8,s1> is NOT a copy => must take care of providers
list of chosen providers: <C9,s1> 
current generation: Generation nr.2: <C8,s1>
next working set, at level nr.1 : { <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 2 ----------------
node to be examined: <C6,s0>
<C6,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 3 ----------------
node to be examined: <C4,s0>
<C4,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C4,s0> <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 4 ----------------
node to be examined: <C2,s0>
<C2,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C2,s0>; <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C2,s0> <C4,s0> <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 5 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C0,s0>; <C2,s0>; <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C0,s0> <C2,s0> <C4,s0> <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 6 ----------------
node to be examined: <C1,s0>
<C1,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 7 ----------------
node to be examined: <C3,s0>
<C3,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 8 ----------------
node to be examined: <C5,s0>
<C5,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C5,s0>; <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C5,s0> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 9 ----------------
node to be examined: <C7,s0>_2
<C7,s0>_2 is an initial node => no need to look for parent and providers
current generation: Generation nr.2: <C7,s0>_2; <C5,s0>; <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C7,s0> <C5,s0> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C6,s0> <C9,s1> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 10 ----------------
node to be examined: <C9,s1>_1
<C9,s1>_1 is NOT an initial node => need to look for parent
<C9,s1> chosen with max fanIn value
origin node chosen: <C9,s1>
Update fanIn : fanIn[<C9,s1>] <- 0 (due to provide p9_1)
current generation: Generation nr.2: <C9,s1>_1; <C7,s0>_2; <C5,s0>; <C3,s0>; <C1,s0>; <C0,s0>; <C2,s0>; <C4,s0>; <C6,s0>; <C8,s1>
next working set, at level nr.1 : { <C9,s1> <C7,s0> <C5,s0> <C3,s0> <C1,s0> <C0,s0> <C2,s0> <C4,s0> <C6,s0> <C8,s0>_1  }
Nodes with fanIn values:
<C0,s0>_1, fanIn = 0 | <C1,s0>_1, fanIn = 0 | <C2,s0>_1, fanIn = 0 | <C3,s0>_1, fanIn = 0 | <C4,s0>_1, fanIn = 0 | <C5,s0>_1, fanIn = 0 | <C6,s0>_1, fanIn = 0 | <C7,s0>_1, fanIn = 0 | <C8,s0>_1, fanIn = 0 | <C9,s0>_1, fanIn = 0 | <C9,s1>, fanIn = 0
Total requires: 
fanIn[<C9,s0>] := 0
fanIn[<C8,s0>] := 0
fanIn[<C7,s0>] := 0
fanIn[<C6,s0>] := 0
fanIn[<C5,s0>] := 0
fanIn[<C4,s0>] := 0
fanIn[<C3,s0>] := 0
fanIn[<C2,s0>] := 0
fanIn[<C1,s0>] := 0
fanIn[<C0,s0>] := 0
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 1 ----------------
node to be examined: <C9,s1>
<C9,s1> is NOT an initial node => need to look for parent
<C9,s0> chosen with max fanIn value
origin node chosen: <C9,s0>
<C9,s1> is NOT a copy => must take care of providers
list of chosen providers: 
current generation: Generation nr.1: <C9,s1>
next working set, at level nr.0 : { <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 2 ----------------
node to be examined: <C7,s0>
<C7,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 3 ----------------
node to be examined: <C5,s0>
<C5,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 4 ----------------
node to be examined: <C3,s0>
<C3,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C3,s0>; <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C3,s0> <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 5 ----------------
node to be examined: <C1,s0>
<C1,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C1,s0>; <C3,s0>; <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C1,s0> <C3,s0> <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 6 ----------------
node to be examined: <C0,s0>
<C0,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 7 ----------------
node to be examined: <C2,s0>
<C2,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 8 ----------------
node to be examined: <C4,s0>
<C4,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C4,s0>; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 9 ----------------
node to be examined: <C6,s0>
<C6,s0> is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C6,s0>; <C4,s0>; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C6,s0> <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 10 ----------------
node to be examined: <C8,s0>_1
<C8,s0>_1 is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <C8,s0>_1; <C6,s0>; <C4,s0>; <C2,s0>; <C0,s0>; <C1,s0>; <C3,s0>; <C5,s0>; <C7,s0>; <C9,s1>
next working set, at level nr.0 : { <C8,s0> <C6,s0> <C4,s0> <C2,s0> <C0,s0> <C1,s0> <C3,s0> <C5,s0> <C7,s0> <C9,s0>  }
Nodes with fanIn values:
<C9,s0>, fanIn = 0 | <C8,s0>, fanIn = 0 | <C7,s0>, fanIn = 0 | <C6,s0>, fanIn = 0 | <C5,s0>, fanIn = 0 | <C4,s0>, fanIn = 0 | <C3,s0>, fanIn = 0 | <C2,s0>, fanIn = 0 | <C1,s0>, fanIn = 0 | <C0,s0>, fanIn = 0

LINEARIZATION phase

The linearized paths are the following:

<C0,s0> <C0,s1> 

<C1,s0> <C1,s1> <C1,s2> 

<C2,s0> <C2,s1> <C2,s2> 

<C3,s0> <C3,s1> <C3,s2> 

<C4,s0> <C4,s1> <C4,s2> 

<C5,s0> <C5,s1> <C5,s2> 

<C6,s0> <C6,s1> <C6,s2> 

<C7,s0> <C7,s1> <C7,s2> 

<C8,s0> <C8,s1> <C8,s2> 

<C9,s0> <C9,s1> <C9,s2> 


The INSTANCE LINES are the following:

Instance c9 :
c9 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C9,s0>--> c9 (s0,s1)

c9 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C9,s1>--> c9 (s1,s2)

c9 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C9,s2>--> c9 (s2,D)

c9 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c8 :
c8 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C8,s0>--> c8 (s0,s1)

c8 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C8,s1>--> c8 (s1,s2)

c8 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C8,s2>--> c8 (s2,D)

c8 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c7 :
c7 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C7,s0>--> c7 (s0,s1)

c7 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C7,s1>--> c7 (s1,s2)

c7 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C7,s2>--> c7 (s2,D)

c7 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c6 :
c6 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C6,s0>--> c6 (s0,s1)

c6 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C6,s1>--> c6 (s1,s2)

c6 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C6,s2>--> c6 (s2,D)

c6 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c5 :
c5 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C5,s0>--> c5 (s0,s1)

c5 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C5,s1>--> c5 (s1,s2)

c5 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C5,s2>--> c5 (s2,D)

c5 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c4 :
c4 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C4,s0>--> c4 (s0,s1)

c4 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C4,s1>--> c4 (s1,s2)

c4 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C4,s2>--> c4 (s2,D)

c4 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c3 :
c3 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C3,s0>--> c3 (s0,s1)

c3 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C3,s1>--> c3 (s1,s2)

c3 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C3,s2>--> c3 (s2,D)

c3 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c2 :
c2 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C2,s0>--> c2 (s0,s1)

c2 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C2,s1>--> c2 (s1,s2)

c2 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C2,s2>--> c2 (s2,D)

c2 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c1 :
c1 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C1,s0>--> c1 (s0,s1)

c1 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C1,s1>--> c1 (s1,s2)

c1 (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C1,s2>--> c1 (s2,D)

c1 (s2,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance c0 :
c0 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C0,s0>--> c0 (s0,s1)

c0 (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C0,s1>--> c0 (s1,D)

c0 (s1,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Next we ADD GO (blue) and RETURN (red) EDGES. 


Now the INSTANCE LINES WITH EDGES look like this:

Instance c9 :
c9 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C9,s0>--> c9 (s0,s1)

c9 (s0,s1) nr.IN-edges =  1
 GO EDGES: ---p9_1---> c8 (s1,s2); ---p9_1---> c8 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C9,s1>--> c9 (s1,s2)

c9 (s1,s2) nr.IN-edges =  2
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C9,s2>--> c9 (s2,D)

c9 (s2,D) nr.IN-edges =  3
 GO EDGES: 
 RETURN EDGES: ---p8_2---> c8 (s2,D)
 INST EDGE: { }

Instance c8 :
c8 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C8,s0>--> c8 (s0,s1)

c8 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p8_1---> c7 (s1,s2); ---p8_1---> c7 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C8,s1>--> c8 (s1,s2)

c8 (s1,s2) nr.IN-edges =  3
 GO EDGES: ---p8_2---> c9 (s1,s2)
 RETURN EDGES: ---p9_1---> c9 (s2,D)
 INST EDGE: --<C8,s2>--> c8 (s2,D)

c8 (s2,D) nr.IN-edges =  4
 GO EDGES: 
 RETURN EDGES: ---p7_2---> c7 (s2,D); ---p9_1---> c9 (s2,D)
 INST EDGE: { }

Instance c7 :
c7 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C7,s0>--> c7 (s0,s1)

c7 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p7_1---> c6 (s1,s2); ---p7_1---> c6 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C7,s1>--> c7 (s1,s2)

c7 (s1,s2) nr.IN-edges =  5
 GO EDGES: ---p7_2---> c8 (s1,s2)
 RETURN EDGES: ---p8_1---> c8 (s2,D)
 INST EDGE: --<C7,s2>--> c7 (s2,D)

c7 (s2,D) nr.IN-edges =  2
 GO EDGES: 
 RETURN EDGES: ---p6_2---> c6 (s2,D); ---p8_1---> c8 (s2,D)
 INST EDGE: { }

Instance c6 :
c6 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C6,s0>--> c6 (s0,s1)

c6 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p6_1---> c5 (s1,s2); ---p6_1---> c5 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C6,s1>--> c6 (s1,s2)

c6 (s1,s2) nr.IN-edges =  3
 GO EDGES: ---p6_2---> c7 (s1,s2)
 RETURN EDGES: ---p7_1---> c7 (s1,s2)
 INST EDGE: --<C6,s2>--> c6 (s2,D)

c6 (s2,D) nr.IN-edges =  4
 GO EDGES: 
 RETURN EDGES: ---p5_2---> c5 (s2,D); ---p7_1---> c7 (s1,s2)
 INST EDGE: { }

Instance c5 :
c5 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C5,s0>--> c5 (s0,s1)

c5 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p5_1---> c4 (s1,s2); ---p5_1---> c4 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C5,s1>--> c5 (s1,s2)

c5 (s1,s2) nr.IN-edges =  3
 GO EDGES: ---p5_2---> c6 (s1,s2)
 RETURN EDGES: ---p6_1---> c6 (s2,D)
 INST EDGE: --<C5,s2>--> c5 (s2,D)

c5 (s2,D) nr.IN-edges =  4
 GO EDGES: 
 RETURN EDGES: ---p4_2---> c4 (s2,D); ---p6_1---> c6 (s2,D)
 INST EDGE: { }

Instance c4 :
c4 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C4,s0>--> c4 (s0,s1)

c4 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p4_1---> c3 (s1,s2); ---p4_1---> c3 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C4,s1>--> c4 (s1,s2)

c4 (s1,s2) nr.IN-edges =  3
 GO EDGES: ---p4_2---> c5 (s1,s2)
 RETURN EDGES: ---p5_1---> c5 (s2,D)
 INST EDGE: --<C4,s2>--> c4 (s2,D)

c4 (s2,D) nr.IN-edges =  4
 GO EDGES: 
 RETURN EDGES: ---p3_2---> c3 (s2,D); ---p5_1---> c5 (s2,D)
 INST EDGE: { }

Instance c3 :
c3 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C3,s0>--> c3 (s0,s1)

c3 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p3_1---> c2 (s1,s2); ---p3_1---> c2 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C3,s1>--> c3 (s1,s2)

c3 (s1,s2) nr.IN-edges =  3
 GO EDGES: ---p3_2---> c4 (s1,s2)
 RETURN EDGES: ---p4_1---> c4 (s2,D)
 INST EDGE: --<C3,s2>--> c3 (s2,D)

c3 (s2,D) nr.IN-edges =  4
 GO EDGES: 
 RETURN EDGES: ---p2_2---> c2 (s2,D); ---p4_1---> c4 (s2,D)
 INST EDGE: { }

Instance c2 :
c2 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C2,s0>--> c2 (s0,s1)

c2 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p2_1---> c1 (s1,s2); ---p2_1---> c1 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C2,s1>--> c2 (s1,s2)

c2 (s1,s2) nr.IN-edges =  5
 GO EDGES: ---p2_2---> c3 (s1,s2)
 RETURN EDGES: ---p3_1---> c3 (s2,D)
 INST EDGE: --<C2,s2>--> c2 (s2,D)

c2 (s2,D) nr.IN-edges =  2
 GO EDGES: 
 RETURN EDGES: ---p1_2---> c1 (s2,D); ---p3_1---> c3 (s2,D)
 INST EDGE: { }

Instance c1 :
c1 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C1,s0>--> c1 (s0,s1)

c1 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p1_1---> c0 (s0,s1)
 RETURN EDGES: 
 INST EDGE: --<C1,s1>--> c1 (s1,s2)

c1 (s1,s2) nr.IN-edges =  3
 GO EDGES: ---p1_2---> c2 (s1,s2)
 RETURN EDGES: ---p2_1---> c2 (s1,s2)
 INST EDGE: --<C1,s2>--> c1 (s2,D)

c1 (s2,D) nr.IN-edges =  3
 GO EDGES: 
 RETURN EDGES: ---p0_2---> c0 (s1,D); ---p2_1---> c2 (s1,s2)
 INST EDGE: { }

Instance c0 :
c0 (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<C0,s0>--> c0 (s0,s1)

c0 (s0,s1) nr.IN-edges =  2
 GO EDGES: ---p0_2---> c1 (s1,s2)
 RETURN EDGES: 
 INST EDGE: --<C0,s1>--> c0 (s1,D)

c0 (s1,D) nr.IN-edges =  2
 GO EDGES: 
 RETURN EDGES: ---p1_1---> c1 (s2,D)
 INST EDGE: { }


----------------------- PLAN SYNTHESIS START -----------------------
Added action [Create instance c9:C9] to the plan.
Added action [Create instance c8:C8] to the plan.
Added action [Create instance c7:C7] to the plan.
Added action [Create instance c6:C6] to the plan.
Added action [Create instance c5:C5] to the plan.
Added action [Create instance c4:C4] to the plan.
Added action [Create instance c3:C3] to the plan.
Added action [Create instance c2:C2] to the plan.
Added action [Create instance c1:C1] to the plan.
Added action [Create instance c0:C0] to the plan.
External loop iteration i = 0

*********************** Internal loop iteration j = 0
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c0 (C,s0)
STACK = 
c1 (C,s0) | c2 (C,s0) | c3 (C,s0) | c4 (C,s0) | c5 (C,s0) | c6 (C,s0) | c7 (C,s0) | c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c0 (C,s0)

*********************** Internal loop iteration j = 1
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c1 (C,s0)
STACK = 
c2 (C,s0) | c3 (C,s0) | c4 (C,s0) | c5 (C,s0) | c6 (C,s0) | c7 (C,s0) | c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c1 (C,s0)

*********************** Internal loop iteration j = 2
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c2 (C,s0)
STACK = 
c3 (C,s0) | c4 (C,s0) | c5 (C,s0) | c6 (C,s0) | c7 (C,s0) | c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c2 (C,s0)

*********************** Internal loop iteration j = 3
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c3 (C,s0)
STACK = 
c4 (C,s0) | c5 (C,s0) | c6 (C,s0) | c7 (C,s0) | c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c3 (C,s0)

*********************** Internal loop iteration j = 4
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c4 (C,s0)
STACK = 
c5 (C,s0) | c6 (C,s0) | c7 (C,s0) | c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c4 (C,s0)

*********************** Internal loop iteration j = 5
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c5 (C,s0)
STACK = 
c6 (C,s0) | c7 (C,s0) | c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c5 (C,s0)

*********************** Internal loop iteration j = 6
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c6 (C,s0)
STACK = 
c7 (C,s0) | c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c6 (C,s0)

*********************** Internal loop iteration j = 7
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c7 (C,s0)
STACK = 
c8 (C,s0) | c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c7 (C,s0)

*********************** Internal loop iteration j = 8
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c8 (C,s0)
STACK = 
c9 (C,s0) | 
Deal with successor vertex.
Vertex removed: c8 (C,s0)

*********************** Internal loop iteration j = 9
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c9 (C,s0)
STACK = 
[]
Deal with successor vertex.
INST Edge: PUSH vertex: c9 (s0,s1)
STACK = 
c9 (s0,s1) | 
Vertex removed: c9 (C,s0)

*********************** Internal loop iteration j = 10
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
Vertex popped: c9 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c9 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c8 (s0,s1)
STACK = 
c8 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c9 (s0,s1)

*********************** Internal loop iteration j = 11
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
Vertex popped: c8 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c8 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c7 (s0,s1)
STACK = 
c7 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c8 (s0,s1)

*********************** Internal loop iteration j = 12
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
Vertex popped: c7 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c7 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c6 (s0,s1)
STACK = 
c6 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c7 (s0,s1)

*********************** Internal loop iteration j = 13
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
Vertex popped: c6 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c6 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c5 (s0,s1)
STACK = 
c5 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c6 (s0,s1)

*********************** Internal loop iteration j = 14
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c6 : change state from s0 to s1]
 Plan[21] = [c6 : bind port p6_1 to instance c5]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
Vertex popped: c5 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c5 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c4 (s0,s1)
STACK = 
c4 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c5 (s0,s1)

*********************** Internal loop iteration j = 15
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c6 : change state from s0 to s1]
 Plan[21] = [c6 : bind port p6_1 to instance c5]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c5 : change state from s0 to s1]
 Plan[24] = [c5 : bind port p5_1 to instance c4]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
Vertex popped: c4 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c4 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c3 (s0,s1)
STACK = 
c3 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c4 (s0,s1)

*********************** Internal loop iteration j = 16
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c6 : change state from s0 to s1]
 Plan[21] = [c6 : bind port p6_1 to instance c5]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c5 : change state from s0 to s1]
 Plan[24] = [c5 : bind port p5_1 to instance c4]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c4 : change state from s0 to s1]
 Plan[27] = [c4 : bind port p4_1 to instance c3]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
Vertex popped: c3 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c3 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c2 (s0,s1)
STACK = 
c2 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c3 (s0,s1)

*********************** Internal loop iteration j = 17
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c6 : change state from s0 to s1]
 Plan[21] = [c6 : bind port p6_1 to instance c5]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c5 : change state from s0 to s1]
 Plan[24] = [c5 : bind port p5_1 to instance c4]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c4 : change state from s0 to s1]
 Plan[27] = [c4 : bind port p4_1 to instance c3]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c3 : change state from s0 to s1]
 Plan[30] = [c3 : bind port p3_1 to instance c2]
 Plan[31] = [c3 : bind port p3_1 to instance c2]
Vertex popped: c2 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c2 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c1 (s0,s1)
STACK = 
c1 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c2 (s0,s1)

*********************** Internal loop iteration j = 18
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c6 : change state from s0 to s1]
 Plan[21] = [c6 : bind port p6_1 to instance c5]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c5 : change state from s0 to s1]
 Plan[24] = [c5 : bind port p5_1 to instance c4]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c4 : change state from s0 to s1]
 Plan[27] = [c4 : bind port p4_1 to instance c3]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c3 : change state from s0 to s1]
 Plan[30] = [c3 : bind port p3_1 to instance c2]
 Plan[31] = [c3 : bind port p3_1 to instance c2]
 Plan[32] = [c2 : change state from s0 to s1]
 Plan[33] = [c2 : bind port p2_1 to instance c1]
 Plan[34] = [c2 : bind port p2_1 to instance c1]
Vertex popped: c1 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c1 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c0 (s0,s1)
STACK = 
c0 (s0,s1) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c1 (s0,s1)

*********************** Internal loop iteration j = 19
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c6 : change state from s0 to s1]
 Plan[21] = [c6 : bind port p6_1 to instance c5]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c5 : change state from s0 to s1]
 Plan[24] = [c5 : bind port p5_1 to instance c4]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c4 : change state from s0 to s1]
 Plan[27] = [c4 : bind port p4_1 to instance c3]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c3 : change state from s0 to s1]
 Plan[30] = [c3 : bind port p3_1 to instance c2]
 Plan[31] = [c3 : bind port p3_1 to instance c2]
 Plan[32] = [c2 : change state from s0 to s1]
 Plan[33] = [c2 : bind port p2_1 to instance c1]
 Plan[34] = [c2 : bind port p2_1 to instance c1]
 Plan[35] = [c1 : change state from s0 to s1]
 Plan[36] = [c1 : bind port p1_1 to instance c0]
Vertex popped: c0 (s0,s1)
STACK = 
[]
It's an intermediate vertex => add action [c0 : change state from s0 to s1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c1 (s1,s2)
STACK = 
c1 (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c0 (s0,s1)

*********************** Internal loop iteration j = 20
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2:C2]
 Plan[9] = [Create instance c1:C1]
 Plan[10] = [Create instance c0:C0]
 Plan[11] = [c9 : change state from s0 to s1]
 Plan[12] = [c9 : bind port p9_1 to instance c8]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c8 : change state from s0 to s1]
 Plan[15] = [c8 : bind port p8_1 to instance c7]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c7 : change state from s0 to s1]
 Plan[18] = [c7 : bind port p7_1 to instance c6]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c6 : change state from s0 to s1]
 Plan[21] = [c6 : bind port p6_1 to instance c5]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c5 : change state from s0 to s1]
 Plan[24] = [c5 : bind port p5_1 to instance c4]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c4 : change state from s0 to s1]
 Plan[27] = [c4 : bind port p4_1 to instance c3]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c3 : change state from s0 to s1]
 Plan[30] = [c3 : bind port p3_1 to instance c2]
 Plan[31] = [c3 : bind port p3_1 to instance c2]
 Plan[32] = [c2 : change state from s0 to s1]
 Plan[33] = [c2 : bind port p2_1 to instance c1]
 Plan[34] = [c2 : bind port p2_1 to instance c1]
 Plan[35] = [c1 : change state from s0 to s1]
 Plan[36] = [c1 : bind port p1_1 to instance c0]
 Plan[37] = [c0 : change state from s0 to s1]
 Plan[38] = [c0 : bind port p0_2 to instance c1]
Vertex popped: c1 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c1 : change state from s1 to s2] to the plan.
Deal with go/blue edges
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c1 (s1,s2)

 ************************* NEED INSTANCE DUPLICATION *************************** 
The list of candidates is the following one: c2 (s1,s2)
Chosen vertex for splitting = c2 (s1,s2)
Built the following new vertex = c2' (s1,D)
Pushed duplicated vertex: c2 (s1,s2)
STACK = 
c2 (s1,s2) | 
External loop iteration i = 1

*********************** Internal loop iteration j = 0
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2':C2]
 Plan[9] = [Create instance c2:C2]
 Plan[10] = [Create instance c1:C1]
 Plan[11] = [Create instance c0:C0]
 Plan[12] = [c9 : change state from s0 to s1]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c8 : change state from s0 to s1]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c8 : bind port p8_1 to instance c7]
 Plan[18] = [c7 : change state from s0 to s1]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c7 : bind port p7_1 to instance c6]
 Plan[21] = [c6 : change state from s0 to s1]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c6 : bind port p6_1 to instance c5]
 Plan[24] = [c5 : change state from s0 to s1]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c5 : bind port p5_1 to instance c4]
 Plan[27] = [c4 : change state from s0 to s1]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c4 : bind port p4_1 to instance c3]
 Plan[30] = [c3 : change state from s0 to s1]
 Plan[31] = [c3 : bind port p3_1 to instance c2']
 Plan[32] = [c3 : bind port p3_1 to instance c2]
 Plan[33] = [c3 : bind port p3_1 to instance c2']
 Plan[34] = [c3 : bind port p3_1 to instance c2]
 Plan[35] = [c2' : change state from s0 to s1]
 Plan[36] = [c2 : change state from s0 to s1]
 Plan[37] = [c2' : bind port p2_1 to instance c1]
 Plan[38] = [c2' : bind port p2_1 to instance c1]
 Plan[39] = [c1 : change state from s0 to s1]
 Plan[40] = [c1 : bind port p1_1 to instance c0]
 Plan[41] = [c0 : change state from s0 to s1]
 Plan[42] = [c0 : bind port p0_2 to instance c1]
 Plan[43] = [c1 : change state from s1 to s2]
 Plan[44] = [c1 : bind port p1_2 to instance c2']
 Plan[45] = [c1 : bind port p1_2 to instance c2]
 Plan[46] = [c1 : unbind port p2_1 from instance c2']
Vertex popped: c2 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c2 : change state from s1 to s2] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c3 (s1,s2)
STACK = 
c3 (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c2 (s1,s2)

*********************** Internal loop iteration j = 1
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2':C2]
 Plan[9] = [Create instance c2:C2]
 Plan[10] = [Create instance c1:C1]
 Plan[11] = [Create instance c0:C0]
 Plan[12] = [c9 : change state from s0 to s1]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c8 : change state from s0 to s1]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c8 : bind port p8_1 to instance c7]
 Plan[18] = [c7 : change state from s0 to s1]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c7 : bind port p7_1 to instance c6]
 Plan[21] = [c6 : change state from s0 to s1]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c6 : bind port p6_1 to instance c5]
 Plan[24] = [c5 : change state from s0 to s1]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c5 : bind port p5_1 to instance c4]
 Plan[27] = [c4 : change state from s0 to s1]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c4 : bind port p4_1 to instance c3]
 Plan[30] = [c3 : change state from s0 to s1]
 Plan[31] = [c3 : bind port p3_1 to instance c2']
 Plan[32] = [c3 : bind port p3_1 to instance c2]
 Plan[33] = [c3 : bind port p3_1 to instance c2']
 Plan[34] = [c3 : bind port p3_1 to instance c2]
 Plan[35] = [c2' : change state from s0 to s1]
 Plan[36] = [c2 : change state from s0 to s1]
 Plan[37] = [c2' : bind port p2_1 to instance c1]
 Plan[38] = [c2' : bind port p2_1 to instance c1]
 Plan[39] = [c1 : change state from s0 to s1]
 Plan[40] = [c1 : bind port p1_1 to instance c0]
 Plan[41] = [c0 : change state from s0 to s1]
 Plan[42] = [c0 : bind port p0_2 to instance c1]
 Plan[43] = [c1 : change state from s1 to s2]
 Plan[44] = [c1 : bind port p1_2 to instance c2']
 Plan[45] = [c1 : bind port p1_2 to instance c2]
 Plan[46] = [c1 : unbind port p2_1 from instance c2']
 Plan[47] = [c2 : change state from s1 to s2]
 Plan[48] = [c2 : bind port p2_2 to instance c3]
 Plan[49] = [c2 : unbind port p3_1 from instance c3]
Vertex popped: c3 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c3 : change state from s1 to s2] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c4 (s1,s2)
STACK = 
c4 (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c3 (s1,s2)

*********************** Internal loop iteration j = 2
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2':C2]
 Plan[9] = [Create instance c2:C2]
 Plan[10] = [Create instance c1:C1]
 Plan[11] = [Create instance c0:C0]
 Plan[12] = [c9 : change state from s0 to s1]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c8 : change state from s0 to s1]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c8 : bind port p8_1 to instance c7]
 Plan[18] = [c7 : change state from s0 to s1]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c7 : bind port p7_1 to instance c6]
 Plan[21] = [c6 : change state from s0 to s1]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c6 : bind port p6_1 to instance c5]
 Plan[24] = [c5 : change state from s0 to s1]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c5 : bind port p5_1 to instance c4]
 Plan[27] = [c4 : change state from s0 to s1]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c4 : bind port p4_1 to instance c3]
 Plan[30] = [c3 : change state from s0 to s1]
 Plan[31] = [c3 : bind port p3_1 to instance c2']
 Plan[32] = [c3 : bind port p3_1 to instance c2]
 Plan[33] = [c3 : bind port p3_1 to instance c2']
 Plan[34] = [c3 : bind port p3_1 to instance c2]
 Plan[35] = [c2' : change state from s0 to s1]
 Plan[36] = [c2 : change state from s0 to s1]
 Plan[37] = [c2' : bind port p2_1 to instance c1]
 Plan[38] = [c2' : bind port p2_1 to instance c1]
 Plan[39] = [c1 : change state from s0 to s1]
 Plan[40] = [c1 : bind port p1_1 to instance c0]
 Plan[41] = [c0 : change state from s0 to s1]
 Plan[42] = [c0 : bind port p0_2 to instance c1]
 Plan[43] = [c1 : change state from s1 to s2]
 Plan[44] = [c1 : bind port p1_2 to instance c2']
 Plan[45] = [c1 : bind port p1_2 to instance c2]
 Plan[46] = [c1 : unbind port p2_1 from instance c2']
 Plan[47] = [c2 : change state from s1 to s2]
 Plan[48] = [c2 : bind port p2_2 to instance c3]
 Plan[49] = [c2 : unbind port p3_1 from instance c3]
 Plan[50] = [c3 : change state from s1 to s2]
 Plan[51] = [c3 : bind port p3_2 to instance c4]
 Plan[52] = [c3 : unbind port p4_1 from instance c4]
Vertex popped: c4 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c4 : change state from s1 to s2] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c5 (s1,s2)
STACK = 
c5 (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c4 (s1,s2)

*********************** Internal loop iteration j = 3
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2':C2]
 Plan[9] = [Create instance c2:C2]
 Plan[10] = [Create instance c1:C1]
 Plan[11] = [Create instance c0:C0]
 Plan[12] = [c9 : change state from s0 to s1]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c8 : change state from s0 to s1]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c8 : bind port p8_1 to instance c7]
 Plan[18] = [c7 : change state from s0 to s1]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c7 : bind port p7_1 to instance c6]
 Plan[21] = [c6 : change state from s0 to s1]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c6 : bind port p6_1 to instance c5]
 Plan[24] = [c5 : change state from s0 to s1]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c5 : bind port p5_1 to instance c4]
 Plan[27] = [c4 : change state from s0 to s1]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c4 : bind port p4_1 to instance c3]
 Plan[30] = [c3 : change state from s0 to s1]
 Plan[31] = [c3 : bind port p3_1 to instance c2']
 Plan[32] = [c3 : bind port p3_1 to instance c2]
 Plan[33] = [c3 : bind port p3_1 to instance c2']
 Plan[34] = [c3 : bind port p3_1 to instance c2]
 Plan[35] = [c2' : change state from s0 to s1]
 Plan[36] = [c2 : change state from s0 to s1]
 Plan[37] = [c2' : bind port p2_1 to instance c1]
 Plan[38] = [c2' : bind port p2_1 to instance c1]
 Plan[39] = [c1 : change state from s0 to s1]
 Plan[40] = [c1 : bind port p1_1 to instance c0]
 Plan[41] = [c0 : change state from s0 to s1]
 Plan[42] = [c0 : bind port p0_2 to instance c1]
 Plan[43] = [c1 : change state from s1 to s2]
 Plan[44] = [c1 : bind port p1_2 to instance c2']
 Plan[45] = [c1 : bind port p1_2 to instance c2]
 Plan[46] = [c1 : unbind port p2_1 from instance c2']
 Plan[47] = [c2 : change state from s1 to s2]
 Plan[48] = [c2 : bind port p2_2 to instance c3]
 Plan[49] = [c2 : unbind port p3_1 from instance c3]
 Plan[50] = [c3 : change state from s1 to s2]
 Plan[51] = [c3 : bind port p3_2 to instance c4]
 Plan[52] = [c3 : unbind port p4_1 from instance c4]
 Plan[53] = [c4 : change state from s1 to s2]
 Plan[54] = [c4 : bind port p4_2 to instance c5]
 Plan[55] = [c4 : unbind port p5_1 from instance c5]
Vertex popped: c5 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c5 : change state from s1 to s2] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c6 (s1,s2)
STACK = 
c6 (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c5 (s1,s2)

*********************** Internal loop iteration j = 4
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7:C7]
 Plan[4] = [Create instance c6:C6]
 Plan[5] = [Create instance c5:C5]
 Plan[6] = [Create instance c4:C4]
 Plan[7] = [Create instance c3:C3]
 Plan[8] = [Create instance c2':C2]
 Plan[9] = [Create instance c2:C2]
 Plan[10] = [Create instance c1:C1]
 Plan[11] = [Create instance c0:C0]
 Plan[12] = [c9 : change state from s0 to s1]
 Plan[13] = [c9 : bind port p9_1 to instance c8]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c8 : change state from s0 to s1]
 Plan[16] = [c8 : bind port p8_1 to instance c7]
 Plan[17] = [c8 : bind port p8_1 to instance c7]
 Plan[18] = [c7 : change state from s0 to s1]
 Plan[19] = [c7 : bind port p7_1 to instance c6]
 Plan[20] = [c7 : bind port p7_1 to instance c6]
 Plan[21] = [c6 : change state from s0 to s1]
 Plan[22] = [c6 : bind port p6_1 to instance c5]
 Plan[23] = [c6 : bind port p6_1 to instance c5]
 Plan[24] = [c5 : change state from s0 to s1]
 Plan[25] = [c5 : bind port p5_1 to instance c4]
 Plan[26] = [c5 : bind port p5_1 to instance c4]
 Plan[27] = [c4 : change state from s0 to s1]
 Plan[28] = [c4 : bind port p4_1 to instance c3]
 Plan[29] = [c4 : bind port p4_1 to instance c3]
 Plan[30] = [c3 : change state from s0 to s1]
 Plan[31] = [c3 : bind port p3_1 to instance c2']
 Plan[32] = [c3 : bind port p3_1 to instance c2]
 Plan[33] = [c3 : bind port p3_1 to instance c2']
 Plan[34] = [c3 : bind port p3_1 to instance c2]
 Plan[35] = [c2' : change state from s0 to s1]
 Plan[36] = [c2 : change state from s0 to s1]
 Plan[37] = [c2' : bind port p2_1 to instance c1]
 Plan[38] = [c2' : bind port p2_1 to instance c1]
 Plan[39] = [c1 : change state from s0 to s1]
 Plan[40] = [c1 : bind port p1_1 to instance c0]
 Plan[41] = [c0 : change state from s0 to s1]
 Plan[42] = [c0 : bind port p0_2 to instance c1]
 Plan[43] = [c1 : change state from s1 to s2]
 Plan[44] = [c1 : bind port p1_2 to instance c2']
 Plan[45] = [c1 : bind port p1_2 to instance c2]
 Plan[46] = [c1 : unbind port p2_1 from instance c2']
 Plan[47] = [c2 : change state from s1 to s2]
 Plan[48] = [c2 : bind port p2_2 to instance c3]
 Plan[49] = [c2 : unbind port p3_1 from instance c3]
 Plan[50] = [c3 : change state from s1 to s2]
 Plan[51] = [c3 : bind port p3_2 to instance c4]
 Plan[52] = [c3 : unbind port p4_1 from instance c4]
 Plan[53] = [c4 : change state from s1 to s2]
 Plan[54] = [c4 : bind port p4_2 to instance c5]
 Plan[55] = [c4 : unbind port p5_1 from instance c5]
 Plan[56] = [c5 : change state from s1 to s2]
 Plan[57] = [c5 : bind port p5_2 to instance c6]
 Plan[58] = [c5 : unbind port p6_1 from instance c6]
Vertex popped: c6 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c6 : change state from s1 to s2] to the plan.
Deal with go/blue edges
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c6 (s1,s2)

 ************************* NEED INSTANCE DUPLICATION *************************** 
The list of candidates is the following one: c7 (s1,s2)
Chosen vertex for splitting = c7 (s1,s2)
Built the following new vertex = c7' (s1,D)
Pushed duplicated vertex: c7 (s1,s2)
STACK = 
c7 (s1,s2) | 
External loop iteration i = 2

*********************** Internal loop iteration j = 0
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7':C7]
 Plan[4] = [Create instance c7:C7]
 Plan[5] = [Create instance c6:C6]
 Plan[6] = [Create instance c5:C5]
 Plan[7] = [Create instance c4:C4]
 Plan[8] = [Create instance c3:C3]
 Plan[9] = [Create instance c2':C2]
 Plan[10] = [Create instance c2:C2]
 Plan[11] = [Create instance c1:C1]
 Plan[12] = [Create instance c0:C0]
 Plan[13] = [c9 : change state from s0 to s1]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c9 : bind port p9_1 to instance c8]
 Plan[16] = [c8 : change state from s0 to s1]
 Plan[17] = [c8 : bind port p8_1 to instance c7']
 Plan[18] = [c8 : bind port p8_1 to instance c7]
 Plan[19] = [c8 : bind port p8_1 to instance c7']
 Plan[20] = [c8 : bind port p8_1 to instance c7]
 Plan[21] = [c7' : change state from s0 to s1]
 Plan[22] = [c7 : change state from s0 to s1]
 Plan[23] = [c7' : bind port p7_1 to instance c6]
 Plan[24] = [c7' : bind port p7_1 to instance c6]
 Plan[25] = [c6 : change state from s0 to s1]
 Plan[26] = [c6 : bind port p6_1 to instance c5]
 Plan[27] = [c6 : bind port p6_1 to instance c5]
 Plan[28] = [c5 : change state from s0 to s1]
 Plan[29] = [c5 : bind port p5_1 to instance c4]
 Plan[30] = [c5 : bind port p5_1 to instance c4]
 Plan[31] = [c4 : change state from s0 to s1]
 Plan[32] = [c4 : bind port p4_1 to instance c3]
 Plan[33] = [c4 : bind port p4_1 to instance c3]
 Plan[34] = [c3 : change state from s0 to s1]
 Plan[35] = [c3 : bind port p3_1 to instance c2']
 Plan[36] = [c3 : bind port p3_1 to instance c2]
 Plan[37] = [c3 : bind port p3_1 to instance c2']
 Plan[38] = [c3 : bind port p3_1 to instance c2]
 Plan[39] = [c2' : change state from s0 to s1]
 Plan[40] = [c2 : change state from s0 to s1]
 Plan[41] = [c2' : bind port p2_1 to instance c1]
 Plan[42] = [c2' : bind port p2_1 to instance c1]
 Plan[43] = [c1 : change state from s0 to s1]
 Plan[44] = [c1 : bind port p1_1 to instance c0]
 Plan[45] = [c0 : change state from s0 to s1]
 Plan[46] = [c0 : bind port p0_2 to instance c1]
 Plan[47] = [c1 : change state from s1 to s2]
 Plan[48] = [c1 : bind port p1_2 to instance c2']
 Plan[49] = [c1 : bind port p1_2 to instance c2]
 Plan[50] = [c1 : unbind port p2_1 from instance c2']
 Plan[51] = [c2 : change state from s1 to s2]
 Plan[52] = [c2 : bind port p2_2 to instance c3]
 Plan[53] = [c2 : unbind port p3_1 from instance c3]
 Plan[54] = [c3 : change state from s1 to s2]
 Plan[55] = [c3 : bind port p3_2 to instance c4]
 Plan[56] = [c3 : unbind port p4_1 from instance c4]
 Plan[57] = [c4 : change state from s1 to s2]
 Plan[58] = [c4 : bind port p4_2 to instance c5]
 Plan[59] = [c4 : unbind port p5_1 from instance c5]
 Plan[60] = [c5 : change state from s1 to s2]
 Plan[61] = [c5 : bind port p5_2 to instance c6]
 Plan[62] = [c5 : unbind port p6_1 from instance c6]
 Plan[63] = [c6 : change state from s1 to s2]
 Plan[64] = [c6 : bind port p6_2 to instance c7']
 Plan[65] = [c6 : bind port p6_2 to instance c7]
 Plan[66] = [c6 : unbind port p7_1 from instance c7']
Vertex popped: c7 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c7 : change state from s1 to s2] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c8 (s1,s2)
STACK = 
c8 (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c7 (s1,s2)

*********************** Internal loop iteration j = 1
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7':C7]
 Plan[4] = [Create instance c7:C7]
 Plan[5] = [Create instance c6:C6]
 Plan[6] = [Create instance c5:C5]
 Plan[7] = [Create instance c4:C4]
 Plan[8] = [Create instance c3:C3]
 Plan[9] = [Create instance c2':C2]
 Plan[10] = [Create instance c2:C2]
 Plan[11] = [Create instance c1:C1]
 Plan[12] = [Create instance c0:C0]
 Plan[13] = [c9 : change state from s0 to s1]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c9 : bind port p9_1 to instance c8]
 Plan[16] = [c8 : change state from s0 to s1]
 Plan[17] = [c8 : bind port p8_1 to instance c7']
 Plan[18] = [c8 : bind port p8_1 to instance c7]
 Plan[19] = [c8 : bind port p8_1 to instance c7']
 Plan[20] = [c8 : bind port p8_1 to instance c7]
 Plan[21] = [c7' : change state from s0 to s1]
 Plan[22] = [c7 : change state from s0 to s1]
 Plan[23] = [c7' : bind port p7_1 to instance c6]
 Plan[24] = [c7' : bind port p7_1 to instance c6]
 Plan[25] = [c6 : change state from s0 to s1]
 Plan[26] = [c6 : bind port p6_1 to instance c5]
 Plan[27] = [c6 : bind port p6_1 to instance c5]
 Plan[28] = [c5 : change state from s0 to s1]
 Plan[29] = [c5 : bind port p5_1 to instance c4]
 Plan[30] = [c5 : bind port p5_1 to instance c4]
 Plan[31] = [c4 : change state from s0 to s1]
 Plan[32] = [c4 : bind port p4_1 to instance c3]
 Plan[33] = [c4 : bind port p4_1 to instance c3]
 Plan[34] = [c3 : change state from s0 to s1]
 Plan[35] = [c3 : bind port p3_1 to instance c2']
 Plan[36] = [c3 : bind port p3_1 to instance c2]
 Plan[37] = [c3 : bind port p3_1 to instance c2']
 Plan[38] = [c3 : bind port p3_1 to instance c2]
 Plan[39] = [c2' : change state from s0 to s1]
 Plan[40] = [c2 : change state from s0 to s1]
 Plan[41] = [c2' : bind port p2_1 to instance c1]
 Plan[42] = [c2' : bind port p2_1 to instance c1]
 Plan[43] = [c1 : change state from s0 to s1]
 Plan[44] = [c1 : bind port p1_1 to instance c0]
 Plan[45] = [c0 : change state from s0 to s1]
 Plan[46] = [c0 : bind port p0_2 to instance c1]
 Plan[47] = [c1 : change state from s1 to s2]
 Plan[48] = [c1 : bind port p1_2 to instance c2']
 Plan[49] = [c1 : bind port p1_2 to instance c2]
 Plan[50] = [c1 : unbind port p2_1 from instance c2']
 Plan[51] = [c2 : change state from s1 to s2]
 Plan[52] = [c2 : bind port p2_2 to instance c3]
 Plan[53] = [c2 : unbind port p3_1 from instance c3]
 Plan[54] = [c3 : change state from s1 to s2]
 Plan[55] = [c3 : bind port p3_2 to instance c4]
 Plan[56] = [c3 : unbind port p4_1 from instance c4]
 Plan[57] = [c4 : change state from s1 to s2]
 Plan[58] = [c4 : bind port p4_2 to instance c5]
 Plan[59] = [c4 : unbind port p5_1 from instance c5]
 Plan[60] = [c5 : change state from s1 to s2]
 Plan[61] = [c5 : bind port p5_2 to instance c6]
 Plan[62] = [c5 : unbind port p6_1 from instance c6]
 Plan[63] = [c6 : change state from s1 to s2]
 Plan[64] = [c6 : bind port p6_2 to instance c7']
 Plan[65] = [c6 : bind port p6_2 to instance c7]
 Plan[66] = [c6 : unbind port p7_1 from instance c7']
 Plan[67] = [c7 : change state from s1 to s2]
 Plan[68] = [c7 : bind port p7_2 to instance c8]
 Plan[69] = [c7 : unbind port p8_1 from instance c8]
Vertex popped: c8 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c8 : change state from s1 to s2] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: c9 (s1,s2)
STACK = 
c9 (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: c8 (s1,s2)

*********************** Internal loop iteration j = 2
Plan BEFORE: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7':C7]
 Plan[4] = [Create instance c7:C7]
 Plan[5] = [Create instance c6:C6]
 Plan[6] = [Create instance c5:C5]
 Plan[7] = [Create instance c4:C4]
 Plan[8] = [Create instance c3:C3]
 Plan[9] = [Create instance c2':C2]
 Plan[10] = [Create instance c2:C2]
 Plan[11] = [Create instance c1:C1]
 Plan[12] = [Create instance c0:C0]
 Plan[13] = [c9 : change state from s0 to s1]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c9 : bind port p9_1 to instance c8]
 Plan[16] = [c8 : change state from s0 to s1]
 Plan[17] = [c8 : bind port p8_1 to instance c7']
 Plan[18] = [c8 : bind port p8_1 to instance c7]
 Plan[19] = [c8 : bind port p8_1 to instance c7']
 Plan[20] = [c8 : bind port p8_1 to instance c7]
 Plan[21] = [c7' : change state from s0 to s1]
 Plan[22] = [c7 : change state from s0 to s1]
 Plan[23] = [c7' : bind port p7_1 to instance c6]
 Plan[24] = [c7' : bind port p7_1 to instance c6]
 Plan[25] = [c6 : change state from s0 to s1]
 Plan[26] = [c6 : bind port p6_1 to instance c5]
 Plan[27] = [c6 : bind port p6_1 to instance c5]
 Plan[28] = [c5 : change state from s0 to s1]
 Plan[29] = [c5 : bind port p5_1 to instance c4]
 Plan[30] = [c5 : bind port p5_1 to instance c4]
 Plan[31] = [c4 : change state from s0 to s1]
 Plan[32] = [c4 : bind port p4_1 to instance c3]
 Plan[33] = [c4 : bind port p4_1 to instance c3]
 Plan[34] = [c3 : change state from s0 to s1]
 Plan[35] = [c3 : bind port p3_1 to instance c2']
 Plan[36] = [c3 : bind port p3_1 to instance c2]
 Plan[37] = [c3 : bind port p3_1 to instance c2']
 Plan[38] = [c3 : bind port p3_1 to instance c2]
 Plan[39] = [c2' : change state from s0 to s1]
 Plan[40] = [c2 : change state from s0 to s1]
 Plan[41] = [c2' : bind port p2_1 to instance c1]
 Plan[42] = [c2' : bind port p2_1 to instance c1]
 Plan[43] = [c1 : change state from s0 to s1]
 Plan[44] = [c1 : bind port p1_1 to instance c0]
 Plan[45] = [c0 : change state from s0 to s1]
 Plan[46] = [c0 : bind port p0_2 to instance c1]
 Plan[47] = [c1 : change state from s1 to s2]
 Plan[48] = [c1 : bind port p1_2 to instance c2']
 Plan[49] = [c1 : bind port p1_2 to instance c2]
 Plan[50] = [c1 : unbind port p2_1 from instance c2']
 Plan[51] = [c2 : change state from s1 to s2]
 Plan[52] = [c2 : bind port p2_2 to instance c3]
 Plan[53] = [c2 : unbind port p3_1 from instance c3]
 Plan[54] = [c3 : change state from s1 to s2]
 Plan[55] = [c3 : bind port p3_2 to instance c4]
 Plan[56] = [c3 : unbind port p4_1 from instance c4]
 Plan[57] = [c4 : change state from s1 to s2]
 Plan[58] = [c4 : bind port p4_2 to instance c5]
 Plan[59] = [c4 : unbind port p5_1 from instance c5]
 Plan[60] = [c5 : change state from s1 to s2]
 Plan[61] = [c5 : bind port p5_2 to instance c6]
 Plan[62] = [c5 : unbind port p6_1 from instance c6]
 Plan[63] = [c6 : change state from s1 to s2]
 Plan[64] = [c6 : bind port p6_2 to instance c7']
 Plan[65] = [c6 : bind port p6_2 to instance c7]
 Plan[66] = [c6 : unbind port p7_1 from instance c7']
 Plan[67] = [c7 : change state from s1 to s2]
 Plan[68] = [c7 : bind port p7_2 to instance c8]
 Plan[69] = [c7 : unbind port p8_1 from instance c8]
 Plan[70] = [c8 : change state from s1 to s2]
 Plan[71] = [c8 : bind port p8_2 to instance c9]
 Plan[72] = [c8 : unbind port p9_1 from instance c9]
Vertex popped: c9 (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [c9 : change state from s1 to s2] to the plan.
Deal with go/blue edges
Deal with return/red edges
Deal with successor vertex.
Target has been REACHED.
Vertex removed: c9 (s1,s2)

The computed PLAN is: 
 Plan[1] = [Create instance c9:C9]
 Plan[2] = [Create instance c8:C8]
 Plan[3] = [Create instance c7':C7]
 Plan[4] = [Create instance c7:C7]
 Plan[5] = [Create instance c6:C6]
 Plan[6] = [Create instance c5:C5]
 Plan[7] = [Create instance c4:C4]
 Plan[8] = [Create instance c3:C3]
 Plan[9] = [Create instance c2':C2]
 Plan[10] = [Create instance c2:C2]
 Plan[11] = [Create instance c1:C1]
 Plan[12] = [Create instance c0:C0]
 Plan[13] = [c9 : change state from s0 to s1]
 Plan[14] = [c9 : bind port p9_1 to instance c8]
 Plan[15] = [c9 : bind port p9_1 to instance c8]
 Plan[16] = [c8 : change state from s0 to s1]
 Plan[17] = [c8 : bind port p8_1 to instance c7']
 Plan[18] = [c8 : bind port p8_1 to instance c7]
 Plan[19] = [c8 : bind port p8_1 to instance c7']
 Plan[20] = [c8 : bind port p8_1 to instance c7]
 Plan[21] = [c7' : change state from s0 to s1]
 Plan[22] = [c7 : change state from s0 to s1]
 Plan[23] = [c7' : bind port p7_1 to instance c6]
 Plan[24] = [c7' : bind port p7_1 to instance c6]
 Plan[25] = [c6 : change state from s0 to s1]
 Plan[26] = [c6 : bind port p6_1 to instance c5]
 Plan[27] = [c6 : bind port p6_1 to instance c5]
 Plan[28] = [c5 : change state from s0 to s1]
 Plan[29] = [c5 : bind port p5_1 to instance c4]
 Plan[30] = [c5 : bind port p5_1 to instance c4]
 Plan[31] = [c4 : change state from s0 to s1]
 Plan[32] = [c4 : bind port p4_1 to instance c3]
 Plan[33] = [c4 : bind port p4_1 to instance c3]
 Plan[34] = [c3 : change state from s0 to s1]
 Plan[35] = [c3 : bind port p3_1 to instance c2']
 Plan[36] = [c3 : bind port p3_1 to instance c2]
 Plan[37] = [c3 : bind port p3_1 to instance c2']
 Plan[38] = [c3 : bind port p3_1 to instance c2]
 Plan[39] = [c2' : change state from s0 to s1]
 Plan[40] = [c2 : change state from s0 to s1]
 Plan[41] = [c2' : bind port p2_1 to instance c1]
 Plan[42] = [c2' : bind port p2_1 to instance c1]
 Plan[43] = [c1 : change state from s0 to s1]
 Plan[44] = [c1 : bind port p1_1 to instance c0]
 Plan[45] = [c0 : change state from s0 to s1]
 Plan[46] = [c0 : bind port p0_2 to instance c1]
 Plan[47] = [c1 : change state from s1 to s2]
 Plan[48] = [c1 : bind port p1_2 to instance c2']
 Plan[49] = [c1 : bind port p1_2 to instance c2]
 Plan[50] = [c1 : unbind port p2_1 from instance c2']
 Plan[51] = [c2 : change state from s1 to s2]
 Plan[52] = [c2 : bind port p2_2 to instance c3]
 Plan[53] = [c2 : unbind port p3_1 from instance c3]
 Plan[54] = [c3 : change state from s1 to s2]
 Plan[55] = [c3 : bind port p3_2 to instance c4]
 Plan[56] = [c3 : unbind port p4_1 from instance c4]
 Plan[57] = [c4 : change state from s1 to s2]
 Plan[58] = [c4 : bind port p4_2 to instance c5]
 Plan[59] = [c4 : unbind port p5_1 from instance c5]
 Plan[60] = [c5 : change state from s1 to s2]
 Plan[61] = [c5 : bind port p5_2 to instance c6]
 Plan[62] = [c5 : unbind port p6_1 from instance c6]
 Plan[63] = [c6 : change state from s1 to s2]
 Plan[64] = [c6 : bind port p6_2 to instance c7']
 Plan[65] = [c6 : bind port p6_2 to instance c7]
 Plan[66] = [c6 : unbind port p7_1 from instance c7']
 Plan[67] = [c7 : change state from s1 to s2]
 Plan[68] = [c7 : bind port p7_2 to instance c8]
 Plan[69] = [c7 : unbind port p8_1 from instance c8]
 Plan[70] = [c8 : change state from s1 to s2]
 Plan[71] = [c8 : bind port p8_2 to instance c9]
 Plan[72] = [c8 : unbind port p9_1 from instance c9]
 Plan[73] = [c9 : change state from s1 to s2]
