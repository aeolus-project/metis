
We generate the FULL G-GRAPH: 

Generation nr.0: <B,q0>; <A,s0>
Generation nr.1: <A,s0>_1; <B,q0>_1; <A,s1>
Generation nr.2: <A,s1>_1; <B,q0>_2; <A,s0>_2; <B,q1>
Generation nr.3: <B,q1>_1; <A,s0>_3; <B,q0>_3; <A,s1>_2; <A,s2>
Generation nr.4: <A,s2>_1; <A,s1>_3; <B,q0>_4; <A,s0>_4; <B,q1>_2; <B,q2>
Generation nr.5: <B,q2>_1; <B,q1>_3; <A,s0>_5; <B,q0>_5; <A,s1>_4; <A,s2>_2; <A,s3>
Generation nr.6: <A,s3>_1; <A,s2>_3; <A,s1>_5; <B,q0>_6; <A,s0>_6; <B,q1>_4; <B,q2>_2; <B,q3>
Generation nr.7: <B,q3>_1; <B,q2>_3; <B,q1>_5; <A,s0>_7; <B,q0>_7; <A,s1>_6; <A,s2>_4; <A,s3>_2; <A,s4>
Generation nr.8: <A,s4>_1; <A,s3>_3; <A,s2>_5; <A,s1>_7; <B,q0>_8; <A,s0>_8; <B,q1>_6; <B,q2>_4; <B,q3>_2; <B,q4>
Generation nr.9: <B,q4>_1; <B,q3>_3; <B,q2>_5; <B,q1>_7; <A,s0>_9; <B,q0>_9; <A,s1>_8; <A,s2>_6; <A,s3>_4; <A,s4>_2; <A,s5>
Generation nr.10: <A,s5>_1; <A,s4>_3; <A,s3>_5; <A,s2>_7; <A,s1>_9; <B,q0>_10; <A,s0>_10; <B,q1>_8; <B,q2>_6; <B,q3>_4; <B,q4>_2; <B,q5>
Generation nr.11: <B,q5>_1; <B,q4>_3; <B,q3>_5; <B,q2>_7; <B,q1>_9; <A,s0>_11; <B,q0>_11; <A,s1>_10; <A,s2>_8; <A,s3>_6; <A,s4>_4; <A,s5>_2; <A,s6>
Generation nr.12: <A,s6>_1; <A,s5>_3; <A,s4>_5; <A,s3>_7; <A,s2>_9; <A,s1>_11; <B,q0>_12; <A,s0>_12; <B,q1>_10; <B,q2>_8; <B,q3>_6; <B,q4>_4; <B,q5>_2; <B,q6>
Generation nr.13: <B,q6>_1; <B,q5>_3; <B,q4>_5; <B,q3>_7; <B,q2>_9; <B,q1>_11; <A,s0>_13; <B,q0>_13; <A,s1>_12; <A,s2>_10; <A,s3>_8; <A,s4>_6; <A,s5>_4; <A,s6>_2; <A,s7>
Generation nr.14: <A,s7>_1; <A,s6>_3; <A,s5>_5; <A,s4>_7; <A,s3>_9; <A,s2>_11; <A,s1>_13; <B,q0>_14; <A,s0>_14; <B,q1>_12; <B,q2>_10; <B,q3>_8; <B,q4>_6; <B,q5>_4; <B,q6>_2; <B,q7>
Generation nr.15: <B,q7>_1; <B,q6>_3; <B,q5>_5; <B,q4>_7; <B,q3>_9; <B,q2>_11; <B,q1>_13; <A,s0>_15; <B,q0>_15; <A,s1>_14; <A,s2>_12; <A,s3>_10; <A,s4>_8; <A,s5>_6; <A,s6>_4; <A,s7>_2; <A,s8>
Generation nr.16: <A,s8>_1; <A,s7>_3; <A,s6>_5; <A,s5>_7; <A,s4>_9; <A,s3>_11; <A,s2>_13; <A,s1>_15; <B,q0>_16; <A,s0>_16; <B,q1>_14; <B,q2>_12; <B,q3>_10; <B,q4>_8; <B,q5>_6; <B,q6>_4; <B,q7>_2; <B,q8>
Generation nr.17: <B,q8>_1; <B,q7>_3; <B,q6>_5; <B,q5>_7; <B,q4>_9; <B,q3>_11; <B,q2>_13; <B,q1>_15; <A,s0>_17; <B,q0>_17; <A,s1>_16; <A,s2>_14; <A,s3>_12; <A,s4>_10; <A,s5>_8; <A,s6>_6; <A,s7>_4; <A,s8>_2; <A,s9>
Generation nr.18: <A,s9>_1; <A,s8>_3; <A,s7>_5; <A,s6>_7; <A,s5>_9; <A,s4>_11; <A,s3>_13; <A,s2>_15; <A,s1>_17; <B,q0>_18; <A,s0>_18; <B,q1>_16; <B,q2>_14; <B,q3>_12; <B,q4>_10; <B,q5>_8; <B,q6>_6; <B,q7>_4; <B,q8>_2; <B,q9>

BOTTOM-UP VISIT of the G-graph. For every node we choose origin node and providers.
Total requires: p0_9
fanIn[<B,q8>_1] := 0
fanIn[<B,q7>_3] := 0
fanIn[<B,q6>_5] := 0
fanIn[<B,q5>_7] := 0
fanIn[<B,q4>_9] := 0
fanIn[<B,q3>_11] := 0
fanIn[<B,q2>_13] := 0
fanIn[<B,q1>_15] := 0
fanIn[<A,s0>_17] := 0
fanIn[<B,q0>_17] := 0
fanIn[<A,s1>_16] := 0
fanIn[<A,s2>_14] := 0
fanIn[<A,s3>_12] := 0
fanIn[<A,s4>_10] := 0
fanIn[<A,s5>_8] := 0
fanIn[<A,s6>_6] := 0
fanIn[<A,s7>_4] := 0
fanIn[<A,s8>_2] := 0
fanIn[<A,s9>] := 1
Nodes with fanIn values:
<B,q8>_1, fanIn = 0 | <B,q7>_3, fanIn = 0 | <B,q6>_5, fanIn = 0 | <B,q5>_7, fanIn = 0 | <B,q4>_9, fanIn = 0 | <B,q3>_11, fanIn = 0 | <B,q2>_13, fanIn = 0 | <B,q1>_15, fanIn = 0 | <A,s0>_17, fanIn = 0 | <B,q0>_17, fanIn = 0 | <A,s1>_16, fanIn = 0 | <A,s2>_14, fanIn = 0 | <A,s3>_12, fanIn = 0 | <A,s4>_10, fanIn = 0 | <A,s5>_8, fanIn = 0 | <A,s6>_6, fanIn = 0 | <A,s7>_4, fanIn = 0 | <A,s8>_2, fanIn = 0 | <A,s9>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 18 CYCLE execution nr. 1 ----------------
node to be examined: <B,q9>
<B,q9> is NOT an initial node => need to look for parent
<B,q8>_1 chosen with max fanIn value
origin node chosen: <B,q8>_1
<B,q9> is NOT a copy => must take care of providers
<A,s9> chosen with max fanIn value
Update fanIn : fanIn[<A,s9>] <- 0 (due to provide p0_9)
list of chosen providers: <A,s9> 
current generation: Generation nr.18: <B,q9>
next working set, at level nr.17 : { <A,s9> <B,q8>_1  }
Nodes with fanIn values:
<B,q8>_1, fanIn = 0 | <B,q7>_3, fanIn = 0 | <B,q6>_5, fanIn = 0 | <B,q5>_7, fanIn = 0 | <B,q4>_9, fanIn = 0 | <B,q3>_11, fanIn = 0 | <B,q2>_13, fanIn = 0 | <B,q1>_15, fanIn = 0 | <A,s0>_17, fanIn = 0 | <B,q0>_17, fanIn = 0 | <A,s1>_16, fanIn = 0 | <A,s2>_14, fanIn = 0 | <A,s3>_12, fanIn = 0 | <A,s4>_10, fanIn = 0 | <A,s5>_8, fanIn = 0 | <A,s6>_6, fanIn = 0 | <A,s7>_4, fanIn = 0 | <A,s8>_2, fanIn = 0 | <A,s9>, fanIn = 0
Total requires: p1_9 | p0_8
fanIn[<A,s8>_1] := 1
fanIn[<A,s7>_3] := 0
fanIn[<A,s6>_5] := 0
fanIn[<A,s5>_7] := 0
fanIn[<A,s4>_9] := 0
fanIn[<A,s3>_11] := 0
fanIn[<A,s2>_13] := 0
fanIn[<A,s1>_15] := 0
fanIn[<B,q0>_16] := 0
fanIn[<A,s0>_16] := 0
fanIn[<B,q1>_14] := 0
fanIn[<B,q2>_12] := 0
fanIn[<B,q3>_10] := 0
fanIn[<B,q4>_8] := 0
fanIn[<B,q5>_6] := 0
fanIn[<B,q6>_4] := 0
fanIn[<B,q7>_2] := 0
fanIn[<B,q8>] := 1
Nodes with fanIn values:
<A,s8>_1, fanIn = 1 | <A,s7>_3, fanIn = 0 | <A,s6>_5, fanIn = 0 | <A,s5>_7, fanIn = 0 | <A,s4>_9, fanIn = 0 | <A,s3>_11, fanIn = 0 | <A,s2>_13, fanIn = 0 | <A,s1>_15, fanIn = 0 | <B,q0>_16, fanIn = 0 | <A,s0>_16, fanIn = 0 | <B,q1>_14, fanIn = 0 | <B,q2>_12, fanIn = 0 | <B,q3>_10, fanIn = 0 | <B,q4>_8, fanIn = 0 | <B,q5>_6, fanIn = 0 | <B,q6>_4, fanIn = 0 | <B,q7>_2, fanIn = 0 | <B,q8>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 17 CYCLE execution nr. 1 ----------------
node to be examined: <A,s9>
<A,s9> is NOT an initial node => need to look for parent
<A,s8>_1 chosen with max fanIn value
origin node chosen: <A,s8>_1
Update fanIn : fanIn[<A,s8>_1] <- 0 (due to provide p0_8)
<A,s9> is NOT a copy => must take care of providers
<B,q8> chosen with max fanIn value
Update fanIn : fanIn[<B,q8>] <- 0 (due to provide p1_8)
list of chosen providers: <B,q8> 
current generation: Generation nr.17: <A,s9>
next working set, at level nr.16 : { <B,q8> <A,s8>_1  }
Nodes with fanIn values:
<A,s8>_1, fanIn = 0 | <A,s7>_3, fanIn = 0 | <A,s6>_5, fanIn = 0 | <A,s5>_7, fanIn = 0 | <A,s4>_9, fanIn = 0 | <A,s3>_11, fanIn = 0 | <A,s2>_13, fanIn = 0 | <A,s1>_15, fanIn = 0 | <B,q0>_16, fanIn = 0 | <A,s0>_16, fanIn = 0 | <B,q1>_14, fanIn = 0 | <B,q2>_12, fanIn = 0 | <B,q3>_10, fanIn = 0 | <B,q4>_8, fanIn = 0 | <B,q5>_6, fanIn = 0 | <B,q6>_4, fanIn = 0 | <B,q7>_2, fanIn = 0 | <B,q8>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 17 CYCLE execution nr. 2 ----------------
node to be examined: <B,q8>_1
<B,q8>_1 is NOT an initial node => need to look for parent
<B,q8> chosen as a copy
origin node chosen: <B,q8>
current generation: Generation nr.17: <B,q8>_1; <A,s9>
next working set, at level nr.16 : { <B,q8> <A,s8>_1  }
Nodes with fanIn values:
<A,s8>_1, fanIn = 0 | <A,s7>_3, fanIn = 0 | <A,s6>_5, fanIn = 0 | <A,s5>_7, fanIn = 0 | <A,s4>_9, fanIn = 0 | <A,s3>_11, fanIn = 0 | <A,s2>_13, fanIn = 0 | <A,s1>_15, fanIn = 0 | <B,q0>_16, fanIn = 0 | <A,s0>_16, fanIn = 0 | <B,q1>_14, fanIn = 0 | <B,q2>_12, fanIn = 0 | <B,q3>_10, fanIn = 0 | <B,q4>_8, fanIn = 0 | <B,q5>_6, fanIn = 0 | <B,q6>_4, fanIn = 0 | <B,q7>_2, fanIn = 0 | <B,q8>, fanIn = 0
Total requires: p0_8 | p1_8
fanIn[<B,q7>_1] := 1
fanIn[<B,q6>_3] := 0
fanIn[<B,q5>_5] := 0
fanIn[<B,q4>_7] := 0
fanIn[<B,q3>_9] := 0
fanIn[<B,q2>_11] := 0
fanIn[<B,q1>_13] := 0
fanIn[<A,s0>_15] := 0
fanIn[<B,q0>_15] := 0
fanIn[<A,s1>_14] := 0
fanIn[<A,s2>_12] := 0
fanIn[<A,s3>_10] := 0
fanIn[<A,s4>_8] := 0
fanIn[<A,s5>_6] := 0
fanIn[<A,s6>_4] := 0
fanIn[<A,s7>_2] := 0
fanIn[<A,s8>] := 1
Nodes with fanIn values:
<B,q7>_1, fanIn = 1 | <B,q6>_3, fanIn = 0 | <B,q5>_5, fanIn = 0 | <B,q4>_7, fanIn = 0 | <B,q3>_9, fanIn = 0 | <B,q2>_11, fanIn = 0 | <B,q1>_13, fanIn = 0 | <A,s0>_15, fanIn = 0 | <B,q0>_15, fanIn = 0 | <A,s1>_14, fanIn = 0 | <A,s2>_12, fanIn = 0 | <A,s3>_10, fanIn = 0 | <A,s4>_8, fanIn = 0 | <A,s5>_6, fanIn = 0 | <A,s6>_4, fanIn = 0 | <A,s7>_2, fanIn = 0 | <A,s8>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 16 CYCLE execution nr. 1 ----------------
node to be examined: <B,q8>
<B,q8> is NOT an initial node => need to look for parent
<B,q7>_1 chosen with max fanIn value
origin node chosen: <B,q7>_1
Update fanIn : fanIn[<B,q7>_1] <- 0 (due to provide p1_7)
<B,q8> is NOT a copy => must take care of providers
<A,s8> chosen with max fanIn value
Update fanIn : fanIn[<A,s8>] <- 0 (due to provide p0_8)
list of chosen providers: <A,s8> 
current generation: Generation nr.16: <B,q8>
next working set, at level nr.15 : { <A,s8> <B,q7>_1  }
Nodes with fanIn values:
<B,q7>_1, fanIn = 0 | <B,q6>_3, fanIn = 0 | <B,q5>_5, fanIn = 0 | <B,q4>_7, fanIn = 0 | <B,q3>_9, fanIn = 0 | <B,q2>_11, fanIn = 0 | <B,q1>_13, fanIn = 0 | <A,s0>_15, fanIn = 0 | <B,q0>_15, fanIn = 0 | <A,s1>_14, fanIn = 0 | <A,s2>_12, fanIn = 0 | <A,s3>_10, fanIn = 0 | <A,s4>_8, fanIn = 0 | <A,s5>_6, fanIn = 0 | <A,s6>_4, fanIn = 0 | <A,s7>_2, fanIn = 0 | <A,s8>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 16 CYCLE execution nr. 2 ----------------
node to be examined: <A,s8>_1
<A,s8>_1 is NOT an initial node => need to look for parent
<A,s8> chosen as a copy
origin node chosen: <A,s8>
current generation: Generation nr.16: <A,s8>_1; <B,q8>
next working set, at level nr.15 : { <A,s8> <B,q7>_1  }
Nodes with fanIn values:
<B,q7>_1, fanIn = 0 | <B,q6>_3, fanIn = 0 | <B,q5>_5, fanIn = 0 | <B,q4>_7, fanIn = 0 | <B,q3>_9, fanIn = 0 | <B,q2>_11, fanIn = 0 | <B,q1>_13, fanIn = 0 | <A,s0>_15, fanIn = 0 | <B,q0>_15, fanIn = 0 | <A,s1>_14, fanIn = 0 | <A,s2>_12, fanIn = 0 | <A,s3>_10, fanIn = 0 | <A,s4>_8, fanIn = 0 | <A,s5>_6, fanIn = 0 | <A,s6>_4, fanIn = 0 | <A,s7>_2, fanIn = 0 | <A,s8>, fanIn = 0
Total requires: p1_8 | p0_7
fanIn[<A,s7>_1] := 1
fanIn[<A,s6>_3] := 0
fanIn[<A,s5>_5] := 0
fanIn[<A,s4>_7] := 0
fanIn[<A,s3>_9] := 0
fanIn[<A,s2>_11] := 0
fanIn[<A,s1>_13] := 0
fanIn[<B,q0>_14] := 0
fanIn[<A,s0>_14] := 0
fanIn[<B,q1>_12] := 0
fanIn[<B,q2>_10] := 0
fanIn[<B,q3>_8] := 0
fanIn[<B,q4>_6] := 0
fanIn[<B,q5>_4] := 0
fanIn[<B,q6>_2] := 0
fanIn[<B,q7>] := 1
Nodes with fanIn values:
<A,s7>_1, fanIn = 1 | <A,s6>_3, fanIn = 0 | <A,s5>_5, fanIn = 0 | <A,s4>_7, fanIn = 0 | <A,s3>_9, fanIn = 0 | <A,s2>_11, fanIn = 0 | <A,s1>_13, fanIn = 0 | <B,q0>_14, fanIn = 0 | <A,s0>_14, fanIn = 0 | <B,q1>_12, fanIn = 0 | <B,q2>_10, fanIn = 0 | <B,q3>_8, fanIn = 0 | <B,q4>_6, fanIn = 0 | <B,q5>_4, fanIn = 0 | <B,q6>_2, fanIn = 0 | <B,q7>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 15 CYCLE execution nr. 1 ----------------
node to be examined: <A,s8>
<A,s8> is NOT an initial node => need to look for parent
<A,s7>_1 chosen with max fanIn value
origin node chosen: <A,s7>_1
Update fanIn : fanIn[<A,s7>_1] <- 0 (due to provide p0_7)
<A,s8> is NOT a copy => must take care of providers
<B,q7> chosen with max fanIn value
Update fanIn : fanIn[<B,q7>] <- 0 (due to provide p1_7)
list of chosen providers: <B,q7> 
current generation: Generation nr.15: <A,s8>
next working set, at level nr.14 : { <B,q7> <A,s7>_1  }
Nodes with fanIn values:
<A,s7>_1, fanIn = 0 | <A,s6>_3, fanIn = 0 | <A,s5>_5, fanIn = 0 | <A,s4>_7, fanIn = 0 | <A,s3>_9, fanIn = 0 | <A,s2>_11, fanIn = 0 | <A,s1>_13, fanIn = 0 | <B,q0>_14, fanIn = 0 | <A,s0>_14, fanIn = 0 | <B,q1>_12, fanIn = 0 | <B,q2>_10, fanIn = 0 | <B,q3>_8, fanIn = 0 | <B,q4>_6, fanIn = 0 | <B,q5>_4, fanIn = 0 | <B,q6>_2, fanIn = 0 | <B,q7>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 15 CYCLE execution nr. 2 ----------------
node to be examined: <B,q7>_1
<B,q7>_1 is NOT an initial node => need to look for parent
<B,q7> chosen as a copy
origin node chosen: <B,q7>
current generation: Generation nr.15: <B,q7>_1; <A,s8>
next working set, at level nr.14 : { <B,q7> <A,s7>_1  }
Nodes with fanIn values:
<A,s7>_1, fanIn = 0 | <A,s6>_3, fanIn = 0 | <A,s5>_5, fanIn = 0 | <A,s4>_7, fanIn = 0 | <A,s3>_9, fanIn = 0 | <A,s2>_11, fanIn = 0 | <A,s1>_13, fanIn = 0 | <B,q0>_14, fanIn = 0 | <A,s0>_14, fanIn = 0 | <B,q1>_12, fanIn = 0 | <B,q2>_10, fanIn = 0 | <B,q3>_8, fanIn = 0 | <B,q4>_6, fanIn = 0 | <B,q5>_4, fanIn = 0 | <B,q6>_2, fanIn = 0 | <B,q7>, fanIn = 0
Total requires: p0_7 | p1_7
fanIn[<B,q6>_1] := 1
fanIn[<B,q5>_3] := 0
fanIn[<B,q4>_5] := 0
fanIn[<B,q3>_7] := 0
fanIn[<B,q2>_9] := 0
fanIn[<B,q1>_11] := 0
fanIn[<A,s0>_13] := 0
fanIn[<B,q0>_13] := 0
fanIn[<A,s1>_12] := 0
fanIn[<A,s2>_10] := 0
fanIn[<A,s3>_8] := 0
fanIn[<A,s4>_6] := 0
fanIn[<A,s5>_4] := 0
fanIn[<A,s6>_2] := 0
fanIn[<A,s7>] := 1
Nodes with fanIn values:
<B,q6>_1, fanIn = 1 | <B,q5>_3, fanIn = 0 | <B,q4>_5, fanIn = 0 | <B,q3>_7, fanIn = 0 | <B,q2>_9, fanIn = 0 | <B,q1>_11, fanIn = 0 | <A,s0>_13, fanIn = 0 | <B,q0>_13, fanIn = 0 | <A,s1>_12, fanIn = 0 | <A,s2>_10, fanIn = 0 | <A,s3>_8, fanIn = 0 | <A,s4>_6, fanIn = 0 | <A,s5>_4, fanIn = 0 | <A,s6>_2, fanIn = 0 | <A,s7>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 1 ----------------
node to be examined: <B,q7>
<B,q7> is NOT an initial node => need to look for parent
<B,q6>_1 chosen with max fanIn value
origin node chosen: <B,q6>_1
Update fanIn : fanIn[<B,q6>_1] <- 0 (due to provide p1_6)
<B,q7> is NOT a copy => must take care of providers
<A,s7> chosen with max fanIn value
Update fanIn : fanIn[<A,s7>] <- 0 (due to provide p0_7)
list of chosen providers: <A,s7> 
current generation: Generation nr.14: <B,q7>
next working set, at level nr.13 : { <A,s7> <B,q6>_1  }
Nodes with fanIn values:
<B,q6>_1, fanIn = 0 | <B,q5>_3, fanIn = 0 | <B,q4>_5, fanIn = 0 | <B,q3>_7, fanIn = 0 | <B,q2>_9, fanIn = 0 | <B,q1>_11, fanIn = 0 | <A,s0>_13, fanIn = 0 | <B,q0>_13, fanIn = 0 | <A,s1>_12, fanIn = 0 | <A,s2>_10, fanIn = 0 | <A,s3>_8, fanIn = 0 | <A,s4>_6, fanIn = 0 | <A,s5>_4, fanIn = 0 | <A,s6>_2, fanIn = 0 | <A,s7>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 14 CYCLE execution nr. 2 ----------------
node to be examined: <A,s7>_1
<A,s7>_1 is NOT an initial node => need to look for parent
<A,s7> chosen as a copy
origin node chosen: <A,s7>
current generation: Generation nr.14: <A,s7>_1; <B,q7>
next working set, at level nr.13 : { <A,s7> <B,q6>_1  }
Nodes with fanIn values:
<B,q6>_1, fanIn = 0 | <B,q5>_3, fanIn = 0 | <B,q4>_5, fanIn = 0 | <B,q3>_7, fanIn = 0 | <B,q2>_9, fanIn = 0 | <B,q1>_11, fanIn = 0 | <A,s0>_13, fanIn = 0 | <B,q0>_13, fanIn = 0 | <A,s1>_12, fanIn = 0 | <A,s2>_10, fanIn = 0 | <A,s3>_8, fanIn = 0 | <A,s4>_6, fanIn = 0 | <A,s5>_4, fanIn = 0 | <A,s6>_2, fanIn = 0 | <A,s7>, fanIn = 0
Total requires: p1_7 | p0_6
fanIn[<A,s6>_1] := 1
fanIn[<A,s5>_3] := 0
fanIn[<A,s4>_5] := 0
fanIn[<A,s3>_7] := 0
fanIn[<A,s2>_9] := 0
fanIn[<A,s1>_11] := 0
fanIn[<B,q0>_12] := 0
fanIn[<A,s0>_12] := 0
fanIn[<B,q1>_10] := 0
fanIn[<B,q2>_8] := 0
fanIn[<B,q3>_6] := 0
fanIn[<B,q4>_4] := 0
fanIn[<B,q5>_2] := 0
fanIn[<B,q6>] := 1
Nodes with fanIn values:
<A,s6>_1, fanIn = 1 | <A,s5>_3, fanIn = 0 | <A,s4>_5, fanIn = 0 | <A,s3>_7, fanIn = 0 | <A,s2>_9, fanIn = 0 | <A,s1>_11, fanIn = 0 | <B,q0>_12, fanIn = 0 | <A,s0>_12, fanIn = 0 | <B,q1>_10, fanIn = 0 | <B,q2>_8, fanIn = 0 | <B,q3>_6, fanIn = 0 | <B,q4>_4, fanIn = 0 | <B,q5>_2, fanIn = 0 | <B,q6>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 1 ----------------
node to be examined: <A,s7>
<A,s7> is NOT an initial node => need to look for parent
<A,s6>_1 chosen with max fanIn value
origin node chosen: <A,s6>_1
Update fanIn : fanIn[<A,s6>_1] <- 0 (due to provide p0_6)
<A,s7> is NOT a copy => must take care of providers
<B,q6> chosen with max fanIn value
Update fanIn : fanIn[<B,q6>] <- 0 (due to provide p1_6)
list of chosen providers: <B,q6> 
current generation: Generation nr.13: <A,s7>
next working set, at level nr.12 : { <B,q6> <A,s6>_1  }
Nodes with fanIn values:
<A,s6>_1, fanIn = 0 | <A,s5>_3, fanIn = 0 | <A,s4>_5, fanIn = 0 | <A,s3>_7, fanIn = 0 | <A,s2>_9, fanIn = 0 | <A,s1>_11, fanIn = 0 | <B,q0>_12, fanIn = 0 | <A,s0>_12, fanIn = 0 | <B,q1>_10, fanIn = 0 | <B,q2>_8, fanIn = 0 | <B,q3>_6, fanIn = 0 | <B,q4>_4, fanIn = 0 | <B,q5>_2, fanIn = 0 | <B,q6>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 13 CYCLE execution nr. 2 ----------------
node to be examined: <B,q6>_1
<B,q6>_1 is NOT an initial node => need to look for parent
<B,q6> chosen as a copy
origin node chosen: <B,q6>
current generation: Generation nr.13: <B,q6>_1; <A,s7>
next working set, at level nr.12 : { <B,q6> <A,s6>_1  }
Nodes with fanIn values:
<A,s6>_1, fanIn = 0 | <A,s5>_3, fanIn = 0 | <A,s4>_5, fanIn = 0 | <A,s3>_7, fanIn = 0 | <A,s2>_9, fanIn = 0 | <A,s1>_11, fanIn = 0 | <B,q0>_12, fanIn = 0 | <A,s0>_12, fanIn = 0 | <B,q1>_10, fanIn = 0 | <B,q2>_8, fanIn = 0 | <B,q3>_6, fanIn = 0 | <B,q4>_4, fanIn = 0 | <B,q5>_2, fanIn = 0 | <B,q6>, fanIn = 0
Total requires: p0_6 | p1_6
fanIn[<B,q5>_1] := 1
fanIn[<B,q4>_3] := 0
fanIn[<B,q3>_5] := 0
fanIn[<B,q2>_7] := 0
fanIn[<B,q1>_9] := 0
fanIn[<A,s0>_11] := 0
fanIn[<B,q0>_11] := 0
fanIn[<A,s1>_10] := 0
fanIn[<A,s2>_8] := 0
fanIn[<A,s3>_6] := 0
fanIn[<A,s4>_4] := 0
fanIn[<A,s5>_2] := 0
fanIn[<A,s6>] := 1
Nodes with fanIn values:
<B,q5>_1, fanIn = 1 | <B,q4>_3, fanIn = 0 | <B,q3>_5, fanIn = 0 | <B,q2>_7, fanIn = 0 | <B,q1>_9, fanIn = 0 | <A,s0>_11, fanIn = 0 | <B,q0>_11, fanIn = 0 | <A,s1>_10, fanIn = 0 | <A,s2>_8, fanIn = 0 | <A,s3>_6, fanIn = 0 | <A,s4>_4, fanIn = 0 | <A,s5>_2, fanIn = 0 | <A,s6>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 1 ----------------
node to be examined: <B,q6>
<B,q6> is NOT an initial node => need to look for parent
<B,q5>_1 chosen with max fanIn value
origin node chosen: <B,q5>_1
Update fanIn : fanIn[<B,q5>_1] <- 0 (due to provide p1_5)
<B,q6> is NOT a copy => must take care of providers
<A,s6> chosen with max fanIn value
Update fanIn : fanIn[<A,s6>] <- 0 (due to provide p0_6)
list of chosen providers: <A,s6> 
current generation: Generation nr.12: <B,q6>
next working set, at level nr.11 : { <A,s6> <B,q5>_1  }
Nodes with fanIn values:
<B,q5>_1, fanIn = 0 | <B,q4>_3, fanIn = 0 | <B,q3>_5, fanIn = 0 | <B,q2>_7, fanIn = 0 | <B,q1>_9, fanIn = 0 | <A,s0>_11, fanIn = 0 | <B,q0>_11, fanIn = 0 | <A,s1>_10, fanIn = 0 | <A,s2>_8, fanIn = 0 | <A,s3>_6, fanIn = 0 | <A,s4>_4, fanIn = 0 | <A,s5>_2, fanIn = 0 | <A,s6>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 12 CYCLE execution nr. 2 ----------------
node to be examined: <A,s6>_1
<A,s6>_1 is NOT an initial node => need to look for parent
<A,s6> chosen as a copy
origin node chosen: <A,s6>
current generation: Generation nr.12: <A,s6>_1; <B,q6>
next working set, at level nr.11 : { <A,s6> <B,q5>_1  }
Nodes with fanIn values:
<B,q5>_1, fanIn = 0 | <B,q4>_3, fanIn = 0 | <B,q3>_5, fanIn = 0 | <B,q2>_7, fanIn = 0 | <B,q1>_9, fanIn = 0 | <A,s0>_11, fanIn = 0 | <B,q0>_11, fanIn = 0 | <A,s1>_10, fanIn = 0 | <A,s2>_8, fanIn = 0 | <A,s3>_6, fanIn = 0 | <A,s4>_4, fanIn = 0 | <A,s5>_2, fanIn = 0 | <A,s6>, fanIn = 0
Total requires: p1_6 | p0_5
fanIn[<A,s5>_1] := 1
fanIn[<A,s4>_3] := 0
fanIn[<A,s3>_5] := 0
fanIn[<A,s2>_7] := 0
fanIn[<A,s1>_9] := 0
fanIn[<B,q0>_10] := 0
fanIn[<A,s0>_10] := 0
fanIn[<B,q1>_8] := 0
fanIn[<B,q2>_6] := 0
fanIn[<B,q3>_4] := 0
fanIn[<B,q4>_2] := 0
fanIn[<B,q5>] := 1
Nodes with fanIn values:
<A,s5>_1, fanIn = 1 | <A,s4>_3, fanIn = 0 | <A,s3>_5, fanIn = 0 | <A,s2>_7, fanIn = 0 | <A,s1>_9, fanIn = 0 | <B,q0>_10, fanIn = 0 | <A,s0>_10, fanIn = 0 | <B,q1>_8, fanIn = 0 | <B,q2>_6, fanIn = 0 | <B,q3>_4, fanIn = 0 | <B,q4>_2, fanIn = 0 | <B,q5>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 1 ----------------
node to be examined: <A,s6>
<A,s6> is NOT an initial node => need to look for parent
<A,s5>_1 chosen with max fanIn value
origin node chosen: <A,s5>_1
Update fanIn : fanIn[<A,s5>_1] <- 0 (due to provide p0_5)
<A,s6> is NOT a copy => must take care of providers
<B,q5> chosen with max fanIn value
Update fanIn : fanIn[<B,q5>] <- 0 (due to provide p1_5)
list of chosen providers: <B,q5> 
current generation: Generation nr.11: <A,s6>
next working set, at level nr.10 : { <B,q5> <A,s5>_1  }
Nodes with fanIn values:
<A,s5>_1, fanIn = 0 | <A,s4>_3, fanIn = 0 | <A,s3>_5, fanIn = 0 | <A,s2>_7, fanIn = 0 | <A,s1>_9, fanIn = 0 | <B,q0>_10, fanIn = 0 | <A,s0>_10, fanIn = 0 | <B,q1>_8, fanIn = 0 | <B,q2>_6, fanIn = 0 | <B,q3>_4, fanIn = 0 | <B,q4>_2, fanIn = 0 | <B,q5>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 11 CYCLE execution nr. 2 ----------------
node to be examined: <B,q5>_1
<B,q5>_1 is NOT an initial node => need to look for parent
<B,q5> chosen as a copy
origin node chosen: <B,q5>
current generation: Generation nr.11: <B,q5>_1; <A,s6>
next working set, at level nr.10 : { <B,q5> <A,s5>_1  }
Nodes with fanIn values:
<A,s5>_1, fanIn = 0 | <A,s4>_3, fanIn = 0 | <A,s3>_5, fanIn = 0 | <A,s2>_7, fanIn = 0 | <A,s1>_9, fanIn = 0 | <B,q0>_10, fanIn = 0 | <A,s0>_10, fanIn = 0 | <B,q1>_8, fanIn = 0 | <B,q2>_6, fanIn = 0 | <B,q3>_4, fanIn = 0 | <B,q4>_2, fanIn = 0 | <B,q5>, fanIn = 0
Total requires: p0_5 | p1_5
fanIn[<B,q4>_1] := 1
fanIn[<B,q3>_3] := 0
fanIn[<B,q2>_5] := 0
fanIn[<B,q1>_7] := 0
fanIn[<A,s0>_9] := 0
fanIn[<B,q0>_9] := 0
fanIn[<A,s1>_8] := 0
fanIn[<A,s2>_6] := 0
fanIn[<A,s3>_4] := 0
fanIn[<A,s4>_2] := 0
fanIn[<A,s5>] := 1
Nodes with fanIn values:
<B,q4>_1, fanIn = 1 | <B,q3>_3, fanIn = 0 | <B,q2>_5, fanIn = 0 | <B,q1>_7, fanIn = 0 | <A,s0>_9, fanIn = 0 | <B,q0>_9, fanIn = 0 | <A,s1>_8, fanIn = 0 | <A,s2>_6, fanIn = 0 | <A,s3>_4, fanIn = 0 | <A,s4>_2, fanIn = 0 | <A,s5>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 1 ----------------
node to be examined: <B,q5>
<B,q5> is NOT an initial node => need to look for parent
<B,q4>_1 chosen with max fanIn value
origin node chosen: <B,q4>_1
Update fanIn : fanIn[<B,q4>_1] <- 0 (due to provide p1_4)
<B,q5> is NOT a copy => must take care of providers
<A,s5> chosen with max fanIn value
Update fanIn : fanIn[<A,s5>] <- 0 (due to provide p0_5)
list of chosen providers: <A,s5> 
current generation: Generation nr.10: <B,q5>
next working set, at level nr.9 : { <A,s5> <B,q4>_1  }
Nodes with fanIn values:
<B,q4>_1, fanIn = 0 | <B,q3>_3, fanIn = 0 | <B,q2>_5, fanIn = 0 | <B,q1>_7, fanIn = 0 | <A,s0>_9, fanIn = 0 | <B,q0>_9, fanIn = 0 | <A,s1>_8, fanIn = 0 | <A,s2>_6, fanIn = 0 | <A,s3>_4, fanIn = 0 | <A,s4>_2, fanIn = 0 | <A,s5>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 10 CYCLE execution nr. 2 ----------------
node to be examined: <A,s5>_1
<A,s5>_1 is NOT an initial node => need to look for parent
<A,s5> chosen as a copy
origin node chosen: <A,s5>
current generation: Generation nr.10: <A,s5>_1; <B,q5>
next working set, at level nr.9 : { <A,s5> <B,q4>_1  }
Nodes with fanIn values:
<B,q4>_1, fanIn = 0 | <B,q3>_3, fanIn = 0 | <B,q2>_5, fanIn = 0 | <B,q1>_7, fanIn = 0 | <A,s0>_9, fanIn = 0 | <B,q0>_9, fanIn = 0 | <A,s1>_8, fanIn = 0 | <A,s2>_6, fanIn = 0 | <A,s3>_4, fanIn = 0 | <A,s4>_2, fanIn = 0 | <A,s5>, fanIn = 0
Total requires: p1_5 | p0_4
fanIn[<A,s4>_1] := 1
fanIn[<A,s3>_3] := 0
fanIn[<A,s2>_5] := 0
fanIn[<A,s1>_7] := 0
fanIn[<B,q0>_8] := 0
fanIn[<A,s0>_8] := 0
fanIn[<B,q1>_6] := 0
fanIn[<B,q2>_4] := 0
fanIn[<B,q3>_2] := 0
fanIn[<B,q4>] := 1
Nodes with fanIn values:
<A,s4>_1, fanIn = 1 | <A,s3>_3, fanIn = 0 | <A,s2>_5, fanIn = 0 | <A,s1>_7, fanIn = 0 | <B,q0>_8, fanIn = 0 | <A,s0>_8, fanIn = 0 | <B,q1>_6, fanIn = 0 | <B,q2>_4, fanIn = 0 | <B,q3>_2, fanIn = 0 | <B,q4>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 1 ----------------
node to be examined: <A,s5>
<A,s5> is NOT an initial node => need to look for parent
<A,s4>_1 chosen with max fanIn value
origin node chosen: <A,s4>_1
Update fanIn : fanIn[<A,s4>_1] <- 0 (due to provide p0_4)
<A,s5> is NOT a copy => must take care of providers
<B,q4> chosen with max fanIn value
Update fanIn : fanIn[<B,q4>] <- 0 (due to provide p1_4)
list of chosen providers: <B,q4> 
current generation: Generation nr.9: <A,s5>
next working set, at level nr.8 : { <B,q4> <A,s4>_1  }
Nodes with fanIn values:
<A,s4>_1, fanIn = 0 | <A,s3>_3, fanIn = 0 | <A,s2>_5, fanIn = 0 | <A,s1>_7, fanIn = 0 | <B,q0>_8, fanIn = 0 | <A,s0>_8, fanIn = 0 | <B,q1>_6, fanIn = 0 | <B,q2>_4, fanIn = 0 | <B,q3>_2, fanIn = 0 | <B,q4>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 9 CYCLE execution nr. 2 ----------------
node to be examined: <B,q4>_1
<B,q4>_1 is NOT an initial node => need to look for parent
<B,q4> chosen as a copy
origin node chosen: <B,q4>
current generation: Generation nr.9: <B,q4>_1; <A,s5>
next working set, at level nr.8 : { <B,q4> <A,s4>_1  }
Nodes with fanIn values:
<A,s4>_1, fanIn = 0 | <A,s3>_3, fanIn = 0 | <A,s2>_5, fanIn = 0 | <A,s1>_7, fanIn = 0 | <B,q0>_8, fanIn = 0 | <A,s0>_8, fanIn = 0 | <B,q1>_6, fanIn = 0 | <B,q2>_4, fanIn = 0 | <B,q3>_2, fanIn = 0 | <B,q4>, fanIn = 0
Total requires: p0_4 | p1_4
fanIn[<B,q3>_1] := 1
fanIn[<B,q2>_3] := 0
fanIn[<B,q1>_5] := 0
fanIn[<A,s0>_7] := 0
fanIn[<B,q0>_7] := 0
fanIn[<A,s1>_6] := 0
fanIn[<A,s2>_4] := 0
fanIn[<A,s3>_2] := 0
fanIn[<A,s4>] := 1
Nodes with fanIn values:
<B,q3>_1, fanIn = 1 | <B,q2>_3, fanIn = 0 | <B,q1>_5, fanIn = 0 | <A,s0>_7, fanIn = 0 | <B,q0>_7, fanIn = 0 | <A,s1>_6, fanIn = 0 | <A,s2>_4, fanIn = 0 | <A,s3>_2, fanIn = 0 | <A,s4>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 1 ----------------
node to be examined: <B,q4>
<B,q4> is NOT an initial node => need to look for parent
<B,q3>_1 chosen with max fanIn value
origin node chosen: <B,q3>_1
Update fanIn : fanIn[<B,q3>_1] <- 0 (due to provide p1_3)
<B,q4> is NOT a copy => must take care of providers
<A,s4> chosen with max fanIn value
Update fanIn : fanIn[<A,s4>] <- 0 (due to provide p0_4)
list of chosen providers: <A,s4> 
current generation: Generation nr.8: <B,q4>
next working set, at level nr.7 : { <A,s4> <B,q3>_1  }
Nodes with fanIn values:
<B,q3>_1, fanIn = 0 | <B,q2>_3, fanIn = 0 | <B,q1>_5, fanIn = 0 | <A,s0>_7, fanIn = 0 | <B,q0>_7, fanIn = 0 | <A,s1>_6, fanIn = 0 | <A,s2>_4, fanIn = 0 | <A,s3>_2, fanIn = 0 | <A,s4>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 8 CYCLE execution nr. 2 ----------------
node to be examined: <A,s4>_1
<A,s4>_1 is NOT an initial node => need to look for parent
<A,s4> chosen as a copy
origin node chosen: <A,s4>
current generation: Generation nr.8: <A,s4>_1; <B,q4>
next working set, at level nr.7 : { <A,s4> <B,q3>_1  }
Nodes with fanIn values:
<B,q3>_1, fanIn = 0 | <B,q2>_3, fanIn = 0 | <B,q1>_5, fanIn = 0 | <A,s0>_7, fanIn = 0 | <B,q0>_7, fanIn = 0 | <A,s1>_6, fanIn = 0 | <A,s2>_4, fanIn = 0 | <A,s3>_2, fanIn = 0 | <A,s4>, fanIn = 0
Total requires: p1_4 | p0_3
fanIn[<A,s3>_1] := 1
fanIn[<A,s2>_3] := 0
fanIn[<A,s1>_5] := 0
fanIn[<B,q0>_6] := 0
fanIn[<A,s0>_6] := 0
fanIn[<B,q1>_4] := 0
fanIn[<B,q2>_2] := 0
fanIn[<B,q3>] := 1
Nodes with fanIn values:
<A,s3>_1, fanIn = 1 | <A,s2>_3, fanIn = 0 | <A,s1>_5, fanIn = 0 | <B,q0>_6, fanIn = 0 | <A,s0>_6, fanIn = 0 | <B,q1>_4, fanIn = 0 | <B,q2>_2, fanIn = 0 | <B,q3>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 1 ----------------
node to be examined: <A,s4>
<A,s4> is NOT an initial node => need to look for parent
<A,s3>_1 chosen with max fanIn value
origin node chosen: <A,s3>_1
Update fanIn : fanIn[<A,s3>_1] <- 0 (due to provide p0_3)
<A,s4> is NOT a copy => must take care of providers
<B,q3> chosen with max fanIn value
Update fanIn : fanIn[<B,q3>] <- 0 (due to provide p1_3)
list of chosen providers: <B,q3> 
current generation: Generation nr.7: <A,s4>
next working set, at level nr.6 : { <B,q3> <A,s3>_1  }
Nodes with fanIn values:
<A,s3>_1, fanIn = 0 | <A,s2>_3, fanIn = 0 | <A,s1>_5, fanIn = 0 | <B,q0>_6, fanIn = 0 | <A,s0>_6, fanIn = 0 | <B,q1>_4, fanIn = 0 | <B,q2>_2, fanIn = 0 | <B,q3>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 7 CYCLE execution nr. 2 ----------------
node to be examined: <B,q3>_1
<B,q3>_1 is NOT an initial node => need to look for parent
<B,q3> chosen as a copy
origin node chosen: <B,q3>
current generation: Generation nr.7: <B,q3>_1; <A,s4>
next working set, at level nr.6 : { <B,q3> <A,s3>_1  }
Nodes with fanIn values:
<A,s3>_1, fanIn = 0 | <A,s2>_3, fanIn = 0 | <A,s1>_5, fanIn = 0 | <B,q0>_6, fanIn = 0 | <A,s0>_6, fanIn = 0 | <B,q1>_4, fanIn = 0 | <B,q2>_2, fanIn = 0 | <B,q3>, fanIn = 0
Total requires: p0_3 | p1_3
fanIn[<B,q2>_1] := 1
fanIn[<B,q1>_3] := 0
fanIn[<A,s0>_5] := 0
fanIn[<B,q0>_5] := 0
fanIn[<A,s1>_4] := 0
fanIn[<A,s2>_2] := 0
fanIn[<A,s3>] := 1
Nodes with fanIn values:
<B,q2>_1, fanIn = 1 | <B,q1>_3, fanIn = 0 | <A,s0>_5, fanIn = 0 | <B,q0>_5, fanIn = 0 | <A,s1>_4, fanIn = 0 | <A,s2>_2, fanIn = 0 | <A,s3>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 1 ----------------
node to be examined: <B,q3>
<B,q3> is NOT an initial node => need to look for parent
<B,q2>_1 chosen with max fanIn value
origin node chosen: <B,q2>_1
Update fanIn : fanIn[<B,q2>_1] <- 0 (due to provide p1_2)
<B,q3> is NOT a copy => must take care of providers
<A,s3> chosen with max fanIn value
Update fanIn : fanIn[<A,s3>] <- 0 (due to provide p0_3)
list of chosen providers: <A,s3> 
current generation: Generation nr.6: <B,q3>
next working set, at level nr.5 : { <A,s3> <B,q2>_1  }
Nodes with fanIn values:
<B,q2>_1, fanIn = 0 | <B,q1>_3, fanIn = 0 | <A,s0>_5, fanIn = 0 | <B,q0>_5, fanIn = 0 | <A,s1>_4, fanIn = 0 | <A,s2>_2, fanIn = 0 | <A,s3>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 6 CYCLE execution nr. 2 ----------------
node to be examined: <A,s3>_1
<A,s3>_1 is NOT an initial node => need to look for parent
<A,s3> chosen as a copy
origin node chosen: <A,s3>
current generation: Generation nr.6: <A,s3>_1; <B,q3>
next working set, at level nr.5 : { <A,s3> <B,q2>_1  }
Nodes with fanIn values:
<B,q2>_1, fanIn = 0 | <B,q1>_3, fanIn = 0 | <A,s0>_5, fanIn = 0 | <B,q0>_5, fanIn = 0 | <A,s1>_4, fanIn = 0 | <A,s2>_2, fanIn = 0 | <A,s3>, fanIn = 0
Total requires: p1_3 | p0_2
fanIn[<A,s2>_1] := 1
fanIn[<A,s1>_3] := 0
fanIn[<B,q0>_4] := 0
fanIn[<A,s0>_4] := 0
fanIn[<B,q1>_2] := 0
fanIn[<B,q2>] := 1
Nodes with fanIn values:
<A,s2>_1, fanIn = 1 | <A,s1>_3, fanIn = 0 | <B,q0>_4, fanIn = 0 | <A,s0>_4, fanIn = 0 | <B,q1>_2, fanIn = 0 | <B,q2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 1 ----------------
node to be examined: <A,s3>
<A,s3> is NOT an initial node => need to look for parent
<A,s2>_1 chosen with max fanIn value
origin node chosen: <A,s2>_1
Update fanIn : fanIn[<A,s2>_1] <- 0 (due to provide p0_2)
<A,s3> is NOT a copy => must take care of providers
<B,q2> chosen with max fanIn value
Update fanIn : fanIn[<B,q2>] <- 0 (due to provide p1_2)
list of chosen providers: <B,q2> 
current generation: Generation nr.5: <A,s3>
next working set, at level nr.4 : { <B,q2> <A,s2>_1  }
Nodes with fanIn values:
<A,s2>_1, fanIn = 0 | <A,s1>_3, fanIn = 0 | <B,q0>_4, fanIn = 0 | <A,s0>_4, fanIn = 0 | <B,q1>_2, fanIn = 0 | <B,q2>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 5 CYCLE execution nr. 2 ----------------
node to be examined: <B,q2>_1
<B,q2>_1 is NOT an initial node => need to look for parent
<B,q2> chosen as a copy
origin node chosen: <B,q2>
current generation: Generation nr.5: <B,q2>_1; <A,s3>
next working set, at level nr.4 : { <B,q2> <A,s2>_1  }
Nodes with fanIn values:
<A,s2>_1, fanIn = 0 | <A,s1>_3, fanIn = 0 | <B,q0>_4, fanIn = 0 | <A,s0>_4, fanIn = 0 | <B,q1>_2, fanIn = 0 | <B,q2>, fanIn = 0
Total requires: p0_2 | p1_2
fanIn[<B,q1>_1] := 1
fanIn[<A,s0>_3] := 0
fanIn[<B,q0>_3] := 0
fanIn[<A,s1>_2] := 0
fanIn[<A,s2>] := 1
Nodes with fanIn values:
<B,q1>_1, fanIn = 1 | <A,s0>_3, fanIn = 0 | <B,q0>_3, fanIn = 0 | <A,s1>_2, fanIn = 0 | <A,s2>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 1 ----------------
node to be examined: <B,q2>
<B,q2> is NOT an initial node => need to look for parent
<B,q1>_1 chosen with max fanIn value
origin node chosen: <B,q1>_1
Update fanIn : fanIn[<B,q1>_1] <- 0 (due to provide p1_2)
<B,q2> is NOT a copy => must take care of providers
<A,s2> chosen with max fanIn value
Update fanIn : fanIn[<A,s2>] <- 0 (due to provide p0_2)
list of chosen providers: <A,s2> 
current generation: Generation nr.4: <B,q2>
next working set, at level nr.3 : { <A,s2> <B,q1>_1  }
Nodes with fanIn values:
<B,q1>_1, fanIn = 0 | <A,s0>_3, fanIn = 0 | <B,q0>_3, fanIn = 0 | <A,s1>_2, fanIn = 0 | <A,s2>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 4 CYCLE execution nr. 2 ----------------
node to be examined: <A,s2>_1
<A,s2>_1 is NOT an initial node => need to look for parent
<A,s2> chosen as a copy
origin node chosen: <A,s2>
current generation: Generation nr.4: <A,s2>_1; <B,q2>
next working set, at level nr.3 : { <A,s2> <B,q1>_1  }
Nodes with fanIn values:
<B,q1>_1, fanIn = 0 | <A,s0>_3, fanIn = 0 | <B,q0>_3, fanIn = 0 | <A,s1>_2, fanIn = 0 | <A,s2>, fanIn = 0
Total requires: p1_2 | p0_1
fanIn[<A,s1>_1] := 1
fanIn[<B,q0>_2] := 0
fanIn[<A,s0>_2] := 0
fanIn[<B,q1>] := 1
Nodes with fanIn values:
<A,s1>_1, fanIn = 1 | <B,q0>_2, fanIn = 0 | <A,s0>_2, fanIn = 0 | <B,q1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 1 ----------------
node to be examined: <A,s2>
<A,s2> is NOT an initial node => need to look for parent
<A,s1>_1 chosen with max fanIn value
origin node chosen: <A,s1>_1
Update fanIn : fanIn[<A,s1>_1] <- 0 (due to provide p0_1)
<A,s2> is NOT a copy => must take care of providers
<B,q1> chosen with max fanIn value
Update fanIn : fanIn[<B,q1>] <- 0 (due to provide p1_2)
list of chosen providers: <B,q1> 
current generation: Generation nr.3: <A,s2>
next working set, at level nr.2 : { <B,q1> <A,s1>_1  }
Nodes with fanIn values:
<A,s1>_1, fanIn = 0 | <B,q0>_2, fanIn = 0 | <A,s0>_2, fanIn = 0 | <B,q1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 3 CYCLE execution nr. 2 ----------------
node to be examined: <B,q1>_1
<B,q1>_1 is NOT an initial node => need to look for parent
<B,q1> chosen as a copy
origin node chosen: <B,q1>
current generation: Generation nr.3: <B,q1>_1; <A,s2>
next working set, at level nr.2 : { <B,q1> <A,s1>_1  }
Nodes with fanIn values:
<A,s1>_1, fanIn = 0 | <B,q0>_2, fanIn = 0 | <A,s0>_2, fanIn = 0 | <B,q1>, fanIn = 0
Total requires: p0_1
fanIn[<A,s0>_1] := 0
fanIn[<B,q0>_1] := 0
fanIn[<A,s1>] := 1
Nodes with fanIn values:
<A,s0>_1, fanIn = 0 | <B,q0>_1, fanIn = 0 | <A,s1>, fanIn = 1

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 1 ----------------
node to be examined: <B,q1>
<B,q1> is NOT an initial node => need to look for parent
<B,q0>_1 chosen with max fanIn value
origin node chosen: <B,q0>_1
<B,q1> is NOT a copy => must take care of providers
<A,s1> chosen with max fanIn value
Update fanIn : fanIn[<A,s1>] <- 0 (due to provide p0_1)
list of chosen providers: <A,s1> 
current generation: Generation nr.2: <B,q1>
next working set, at level nr.1 : { <A,s1> <B,q0>_1  }
Nodes with fanIn values:
<A,s0>_1, fanIn = 0 | <B,q0>_1, fanIn = 0 | <A,s1>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 2 CYCLE execution nr. 2 ----------------
node to be examined: <A,s1>_1
<A,s1>_1 is NOT an initial node => need to look for parent
<A,s1> chosen as a copy
origin node chosen: <A,s1>
current generation: Generation nr.2: <A,s1>_1; <B,q1>
next working set, at level nr.1 : { <A,s1> <B,q0>_1  }
Nodes with fanIn values:
<A,s0>_1, fanIn = 0 | <B,q0>_1, fanIn = 0 | <A,s1>, fanIn = 0
Total requires: 
fanIn[<B,q0>] := 0
fanIn[<A,s0>] := 0
Nodes with fanIn values:
<B,q0>, fanIn = 0 | <A,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 1 ----------------
node to be examined: <A,s1>
<A,s1> is NOT an initial node => need to look for parent
<A,s0> chosen with max fanIn value
origin node chosen: <A,s0>
<A,s1> is NOT a copy => must take care of providers
list of chosen providers: 
current generation: Generation nr.1: <A,s1>
next working set, at level nr.0 : { <A,s0>  }
Nodes with fanIn values:
<B,q0>, fanIn = 0 | <A,s0>, fanIn = 0

 ----------------- BOTTOM-UP VISIT LEVEL nr. 1 CYCLE execution nr. 2 ----------------
node to be examined: <B,q0>_1
<B,q0>_1 is an initial node => no need to look for parent and providers
current generation: Generation nr.1: <B,q0>_1; <A,s1>
next working set, at level nr.0 : { <B,q0> <A,s0>  }
Nodes with fanIn values:
<B,q0>, fanIn = 0 | <A,s0>, fanIn = 0

LINEARIZATION phase

The linearized paths are the following:

<A,s0> <A,s1> <A,s2> <A,s3> <A,s4> <A,s5> <A,s6> <A,s7> <A,s8> <A,s9> 

<B,q0> <B,q1> <B,q2> <B,q3> <B,q4> <B,q5> <B,q6> <B,q7> <B,q8> <B,q9> 


The INSTANCE LINES are the following:

Instance b :
b (C,q0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q0>--> b (q0,q1)

b (q0,q1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q1>--> b (q1,q2)

b (q1,q2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q2>--> b (q2,q3)

b (q2,q3) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q3>--> b (q3,q4)

b (q3,q4) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q4>--> b (q4,q5)

b (q4,q5) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q5>--> b (q5,q6)

b (q5,q6) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q6>--> b (q6,q7)

b (q6,q7) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q7>--> b (q7,q8)

b (q7,q8) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q8>--> b (q8,q9)

b (q8,q9) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q9>--> b (q9,D)

b (q9,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Instance a :
a (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s0>--> a (s0,s1)

a (s0,s1) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s1>--> a (s1,s2)

a (s1,s2) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s2>--> a (s2,s3)

a (s2,s3) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s3>--> a (s3,s4)

a (s3,s4) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s4>--> a (s4,s5)

a (s4,s5) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s5>--> a (s5,s6)

a (s5,s6) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s6>--> a (s6,s7)

a (s6,s7) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s7>--> a (s7,s8)

a (s7,s8) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s8>--> a (s8,s9)

a (s8,s9) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s9>--> a (s9,D)

a (s9,D) nr.IN-edges =  1
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: { }

Next we ADD GO (blue) and RETURN (red) EDGES. 


Now the INSTANCE LINES WITH EDGES look like this:

Instance b :
b (C,q0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<B,q0>--> b (q0,q1)

b (q0,q1) nr.IN-edges =  2
 GO EDGES: ---p1_2---> a (s1,s2)
 RETURN EDGES: 
 INST EDGE: --<B,q1>--> b (q1,q2)

b (q1,q2) nr.IN-edges =  2
 GO EDGES: ---p1_3---> a (s2,s3)
 RETURN EDGES: ---p0_1---> a (s2,s3)
 INST EDGE: --<B,q2>--> b (q2,q3)

b (q2,q3) nr.IN-edges =  3
 GO EDGES: ---p1_4---> a (s3,s4)
 RETURN EDGES: ---p0_2---> a (s3,s4)
 INST EDGE: --<B,q3>--> b (q3,q4)

b (q3,q4) nr.IN-edges =  3
 GO EDGES: ---p1_5---> a (s4,s5)
 RETURN EDGES: ---p0_3---> a (s4,s5)
 INST EDGE: --<B,q4>--> b (q4,q5)

b (q4,q5) nr.IN-edges =  3
 GO EDGES: ---p1_6---> a (s5,s6)
 RETURN EDGES: ---p0_4---> a (s5,s6)
 INST EDGE: --<B,q5>--> b (q5,q6)

b (q5,q6) nr.IN-edges =  3
 GO EDGES: ---p1_7---> a (s6,s7)
 RETURN EDGES: ---p0_5---> a (s6,s7)
 INST EDGE: --<B,q6>--> b (q6,q7)

b (q6,q7) nr.IN-edges =  3
 GO EDGES: ---p1_8---> a (s7,s8)
 RETURN EDGES: ---p0_6---> a (s7,s8)
 INST EDGE: --<B,q7>--> b (q7,q8)

b (q7,q8) nr.IN-edges =  3
 GO EDGES: ---p1_9---> a (s8,s9)
 RETURN EDGES: ---p0_7---> a (s8,s9)
 INST EDGE: --<B,q8>--> b (q8,q9)

b (q8,q9) nr.IN-edges =  3
 GO EDGES: 
 RETURN EDGES: ---p0_8---> a (s9,D)
 INST EDGE: --<B,q9>--> b (q9,D)

b (q9,D) nr.IN-edges =  2
 GO EDGES: 
 RETURN EDGES: ---p0_9---> a (s9,D)
 INST EDGE: { }

Instance a :
a (C,s0) nr.IN-edges =  0
 GO EDGES: 
 RETURN EDGES: 
 INST EDGE: --<A,s0>--> a (s0,s1)

a (s0,s1) nr.IN-edges =  1
 GO EDGES: ---p0_1---> b (q0,q1)
 RETURN EDGES: 
 INST EDGE: --<A,s1>--> a (s1,s2)

a (s1,s2) nr.IN-edges =  2
 GO EDGES: ---p0_2---> b (q1,q2)
 RETURN EDGES: 
 INST EDGE: --<A,s2>--> a (s2,s3)

a (s2,s3) nr.IN-edges =  3
 GO EDGES: ---p0_3---> b (q2,q3)
 RETURN EDGES: ---p1_2---> b (q2,q3)
 INST EDGE: --<A,s3>--> a (s3,s4)

a (s3,s4) nr.IN-edges =  3
 GO EDGES: ---p0_4---> b (q3,q4)
 RETURN EDGES: ---p1_3---> b (q3,q4)
 INST EDGE: --<A,s4>--> a (s4,s5)

a (s4,s5) nr.IN-edges =  3
 GO EDGES: ---p0_5---> b (q4,q5)
 RETURN EDGES: ---p1_4---> b (q4,q5)
 INST EDGE: --<A,s5>--> a (s5,s6)

a (s5,s6) nr.IN-edges =  3
 GO EDGES: ---p0_6---> b (q5,q6)
 RETURN EDGES: ---p1_5---> b (q5,q6)
 INST EDGE: --<A,s6>--> a (s6,s7)

a (s6,s7) nr.IN-edges =  3
 GO EDGES: ---p0_7---> b (q6,q7)
 RETURN EDGES: ---p1_6---> b (q6,q7)
 INST EDGE: --<A,s7>--> a (s7,s8)

a (s7,s8) nr.IN-edges =  3
 GO EDGES: ---p0_8---> b (q7,q8)
 RETURN EDGES: ---p1_7---> b (q7,q8)
 INST EDGE: --<A,s8>--> a (s8,s9)

a (s8,s9) nr.IN-edges =  3
 GO EDGES: ---p0_9---> b (q8,q9)
 RETURN EDGES: ---p1_8---> b (q8,q9)
 INST EDGE: --<A,s9>--> a (s9,D)

a (s9,D) nr.IN-edges =  3
 GO EDGES: 
 RETURN EDGES: ---p1_9---> b (q9,D)
 INST EDGE: { }


----------------------- PLAN SYNTHESIS START -----------------------
Added action [Create instance b:B] to the plan.
Added action [Create instance a:A] to the plan.
External loop iteration i = 0

*********************** Internal loop iteration j = 0
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
Vertex popped: a (C,s0)
STACK = 
b (C,q0) | 
Deal with successor vertex.
INST Edge: PUSH vertex: a (s0,s1)
STACK = 
a (s0,s1) | b (C,q0) | 
Vertex removed: a (C,s0)

*********************** Internal loop iteration j = 1
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
Vertex popped: a (s0,s1)
STACK = 
b (C,q0) | 
It's an intermediate vertex => add action [a : change state from s0 to s1] to the plan.
Deal with go/blue edges
Deal with return/red edges
Deal with successor vertex.
Vertex removed: a (s0,s1)

*********************** Internal loop iteration j = 2
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
Vertex popped: b (C,q0)
STACK = 
[]
Deal with successor vertex.
INST Edge: PUSH vertex: b (q0,q1)
STACK = 
b (q0,q1) | 
Vertex removed: b (C,q0)

*********************** Internal loop iteration j = 3
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
Vertex popped: b (q0,q1)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q0 to q1] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: a (s1,s2)
STACK = 
a (s1,s2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: b (q0,q1)

*********************** Internal loop iteration j = 4
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
Vertex popped: a (s1,s2)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s1 to s2] to the plan.
Deal with go/blue edges
GO Edge: PUSH vertex: b (q1,q2)
STACK = 
b (q1,q2) | 
Deal with return/red edges
Deal with successor vertex.
Vertex removed: a (s1,s2)

*********************** Internal loop iteration j = 5
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
Vertex popped: b (q1,q2)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q1 to q2] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: a (s2,s3)
STACK = 
a (s2,s3) | 
Deal with successor vertex.
Vertex removed: b (q1,q2)

*********************** Internal loop iteration j = 6
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
Vertex popped: a (s2,s3)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s2 to s3] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: b (q2,q3)
STACK = 
b (q2,q3) | 
Deal with successor vertex.
Vertex removed: a (s2,s3)

*********************** Internal loop iteration j = 7
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
Vertex popped: b (q2,q3)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q2 to q3] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: a (s3,s4)
STACK = 
a (s3,s4) | 
Deal with successor vertex.
Vertex removed: b (q2,q3)

*********************** Internal loop iteration j = 8
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
Vertex popped: a (s3,s4)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s3 to s4] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: b (q3,q4)
STACK = 
b (q3,q4) | 
Deal with successor vertex.
Vertex removed: a (s3,s4)

*********************** Internal loop iteration j = 9
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
Vertex popped: b (q3,q4)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q3 to q4] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: a (s4,s5)
STACK = 
a (s4,s5) | 
Deal with successor vertex.
Vertex removed: b (q3,q4)

*********************** Internal loop iteration j = 10
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
Vertex popped: a (s4,s5)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s4 to s5] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: b (q4,q5)
STACK = 
b (q4,q5) | 
Deal with successor vertex.
Vertex removed: a (s4,s5)

*********************** Internal loop iteration j = 11
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
Vertex popped: b (q4,q5)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q4 to q5] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: a (s5,s6)
STACK = 
a (s5,s6) | 
Deal with successor vertex.
Vertex removed: b (q4,q5)

*********************** Internal loop iteration j = 12
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
Vertex popped: a (s5,s6)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s5 to s6] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: b (q5,q6)
STACK = 
b (q5,q6) | 
Deal with successor vertex.
Vertex removed: a (s5,s6)

*********************** Internal loop iteration j = 13
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
Vertex popped: b (q5,q6)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q5 to q6] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: a (s6,s7)
STACK = 
a (s6,s7) | 
Deal with successor vertex.
Vertex removed: b (q5,q6)

*********************** Internal loop iteration j = 14
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
 Plan[33] = [b : change state from q5 to q6]
 Plan[34] = [b : bind port p1_7 to instance a]
 Plan[35] = [b : unbind port p0_5 from instance a]
Vertex popped: a (s6,s7)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s6 to s7] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: b (q6,q7)
STACK = 
b (q6,q7) | 
Deal with successor vertex.
Vertex removed: a (s6,s7)

*********************** Internal loop iteration j = 15
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
 Plan[33] = [b : change state from q5 to q6]
 Plan[34] = [b : bind port p1_7 to instance a]
 Plan[35] = [b : unbind port p0_5 from instance a]
 Plan[36] = [a : change state from s6 to s7]
 Plan[37] = [a : bind port p0_7 to instance b]
 Plan[38] = [a : unbind port p1_6 from instance b]
Vertex popped: b (q6,q7)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q6 to q7] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: a (s7,s8)
STACK = 
a (s7,s8) | 
Deal with successor vertex.
Vertex removed: b (q6,q7)

*********************** Internal loop iteration j = 16
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
 Plan[33] = [b : change state from q5 to q6]
 Plan[34] = [b : bind port p1_7 to instance a]
 Plan[35] = [b : unbind port p0_5 from instance a]
 Plan[36] = [a : change state from s6 to s7]
 Plan[37] = [a : bind port p0_7 to instance b]
 Plan[38] = [a : unbind port p1_6 from instance b]
 Plan[39] = [b : change state from q6 to q7]
 Plan[40] = [b : bind port p1_8 to instance a]
 Plan[41] = [b : unbind port p0_6 from instance a]
Vertex popped: a (s7,s8)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s7 to s8] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: b (q7,q8)
STACK = 
b (q7,q8) | 
Deal with successor vertex.
Vertex removed: a (s7,s8)

*********************** Internal loop iteration j = 17
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
 Plan[33] = [b : change state from q5 to q6]
 Plan[34] = [b : bind port p1_7 to instance a]
 Plan[35] = [b : unbind port p0_5 from instance a]
 Plan[36] = [a : change state from s6 to s7]
 Plan[37] = [a : bind port p0_7 to instance b]
 Plan[38] = [a : unbind port p1_6 from instance b]
 Plan[39] = [b : change state from q6 to q7]
 Plan[40] = [b : bind port p1_8 to instance a]
 Plan[41] = [b : unbind port p0_6 from instance a]
 Plan[42] = [a : change state from s7 to s8]
 Plan[43] = [a : bind port p0_8 to instance b]
 Plan[44] = [a : unbind port p1_7 from instance b]
Vertex popped: b (q7,q8)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q7 to q8] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: a (s8,s9)
STACK = 
a (s8,s9) | 
Deal with successor vertex.
Vertex removed: b (q7,q8)

*********************** Internal loop iteration j = 18
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
 Plan[33] = [b : change state from q5 to q6]
 Plan[34] = [b : bind port p1_7 to instance a]
 Plan[35] = [b : unbind port p0_5 from instance a]
 Plan[36] = [a : change state from s6 to s7]
 Plan[37] = [a : bind port p0_7 to instance b]
 Plan[38] = [a : unbind port p1_6 from instance b]
 Plan[39] = [b : change state from q6 to q7]
 Plan[40] = [b : bind port p1_8 to instance a]
 Plan[41] = [b : unbind port p0_6 from instance a]
 Plan[42] = [a : change state from s7 to s8]
 Plan[43] = [a : bind port p0_8 to instance b]
 Plan[44] = [a : unbind port p1_7 from instance b]
 Plan[45] = [b : change state from q7 to q8]
 Plan[46] = [b : bind port p1_9 to instance a]
 Plan[47] = [b : unbind port p0_7 from instance a]
Vertex popped: a (s8,s9)
STACK = 
[]
It's an intermediate vertex => add action [a : change state from s8 to s9] to the plan.
Deal with go/blue edges
Deal with return/red edges
RETURN Edge: PUSH vertex: b (q8,q9)
STACK = 
b (q8,q9) | 
Deal with successor vertex.
Vertex removed: a (s8,s9)

*********************** Internal loop iteration j = 19
Plan BEFORE: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
 Plan[33] = [b : change state from q5 to q6]
 Plan[34] = [b : bind port p1_7 to instance a]
 Plan[35] = [b : unbind port p0_5 from instance a]
 Plan[36] = [a : change state from s6 to s7]
 Plan[37] = [a : bind port p0_7 to instance b]
 Plan[38] = [a : unbind port p1_6 from instance b]
 Plan[39] = [b : change state from q6 to q7]
 Plan[40] = [b : bind port p1_8 to instance a]
 Plan[41] = [b : unbind port p0_6 from instance a]
 Plan[42] = [a : change state from s7 to s8]
 Plan[43] = [a : bind port p0_8 to instance b]
 Plan[44] = [a : unbind port p1_7 from instance b]
 Plan[45] = [b : change state from q7 to q8]
 Plan[46] = [b : bind port p1_9 to instance a]
 Plan[47] = [b : unbind port p0_7 from instance a]
 Plan[48] = [a : change state from s8 to s9]
 Plan[49] = [a : bind port p0_9 to instance b]
 Plan[50] = [a : unbind port p1_8 from instance b]
Vertex popped: b (q8,q9)
STACK = 
[]
It's an intermediate vertex => add action [b : change state from q8 to q9] to the plan.
Deal with go/blue edges
Deal with return/red edges
Deal with successor vertex.
Target has been REACHED.
Vertex removed: b (q8,q9)

The computed PLAN is: 
 Plan[1] = [Create instance b:B]
 Plan[2] = [Create instance a:A]
 Plan[3] = [a : change state from s0 to s1]
 Plan[4] = [a : bind port p0_1 to instance b]
 Plan[5] = [b : change state from q0 to q1]
 Plan[6] = [b : bind port p1_2 to instance a]
 Plan[7] = [a : change state from s1 to s2]
 Plan[8] = [a : bind port p0_2 to instance b]
 Plan[9] = [b : change state from q1 to q2]
 Plan[10] = [b : bind port p1_3 to instance a]
 Plan[11] = [b : unbind port p0_1 from instance a]
 Plan[12] = [a : change state from s2 to s3]
 Plan[13] = [a : bind port p0_3 to instance b]
 Plan[14] = [a : unbind port p1_2 from instance b]
 Plan[15] = [b : change state from q2 to q3]
 Plan[16] = [b : bind port p1_4 to instance a]
 Plan[17] = [b : unbind port p0_2 from instance a]
 Plan[18] = [a : change state from s3 to s4]
 Plan[19] = [a : bind port p0_4 to instance b]
 Plan[20] = [a : unbind port p1_3 from instance b]
 Plan[21] = [b : change state from q3 to q4]
 Plan[22] = [b : bind port p1_5 to instance a]
 Plan[23] = [b : unbind port p0_3 from instance a]
 Plan[24] = [a : change state from s4 to s5]
 Plan[25] = [a : bind port p0_5 to instance b]
 Plan[26] = [a : unbind port p1_4 from instance b]
 Plan[27] = [b : change state from q4 to q5]
 Plan[28] = [b : bind port p1_6 to instance a]
 Plan[29] = [b : unbind port p0_4 from instance a]
 Plan[30] = [a : change state from s5 to s6]
 Plan[31] = [a : bind port p0_6 to instance b]
 Plan[32] = [a : unbind port p1_5 from instance b]
 Plan[33] = [b : change state from q5 to q6]
 Plan[34] = [b : bind port p1_7 to instance a]
 Plan[35] = [b : unbind port p0_5 from instance a]
 Plan[36] = [a : change state from s6 to s7]
 Plan[37] = [a : bind port p0_7 to instance b]
 Plan[38] = [a : unbind port p1_6 from instance b]
 Plan[39] = [b : change state from q6 to q7]
 Plan[40] = [b : bind port p1_8 to instance a]
 Plan[41] = [b : unbind port p0_6 from instance a]
 Plan[42] = [a : change state from s7 to s8]
 Plan[43] = [a : bind port p0_8 to instance b]
 Plan[44] = [a : unbind port p1_7 from instance b]
 Plan[45] = [b : change state from q7 to q8]
 Plan[46] = [b : bind port p1_9 to instance a]
 Plan[47] = [b : unbind port p0_7 from instance a]
 Plan[48] = [a : change state from s8 to s9]
 Plan[49] = [a : bind port p0_9 to instance b]
 Plan[50] = [a : unbind port p1_8 from instance b]
 Plan[51] = [b : change state from q8 to q9]
 Plan[52] = [b : unbind port p0_8 from instance a]
